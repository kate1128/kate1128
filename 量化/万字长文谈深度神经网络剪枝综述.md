<font style="color:rgb(25, 27, 31);">参考文档：</font>

+ <font style="color:rgb(25, 27, 31);">A Survey on Deep Neural Network Pruning: Taxonomy, Comparison, Analysis, and Recommendations</font>

[2308.06767v2.pdf](https://www.yuque.com/attachments/yuque/0/2025/pdf/2639475/1740121881385-25464ddd-badd-4d0b-9855-22010aba7ad5.pdf)

+ [https://arxiv.org/abs/1712.01312](https://arxiv.org/abs/1712.01312)

[1712.01312v2.pdf](https://www.yuque.com/attachments/yuque/0/2025/pdf/2639475/1740121880258-59c43c41-8072-41ad-81f5-6a60f3295b44.pdf)

+ [https://arxiv.org/abs/1801.05787](https://arxiv.org/abs/1801.05787)

[1801.05787v2.pdf](https://www.yuque.com/attachments/yuque/0/2025/pdf/2639475/1740121887201-a03e7d80-b9a0-411e-92bc-5e0cee4437db.pdf)

+ [https://github.com/hrcheng1066/awesome-pruning](https://github.com/hrcheng1066/awesome-pruning)

## <font style="color:rgb(25, 27, 31);"> 摘要</font>
<font style="color:rgb(25, 27, 31);">现代</font>[<font style="color:rgb(9, 64, 142);">深度神经网络</font>](https://zhida.zhihu.com/search?content_id=242099111&content_type=Article&match_order=1&q=%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C&zhida_source=entity)<font style="color:rgb(25, 27, 31);">，特别是最近的大语言模型，具有巨大的模型大小，需要大量的计算和存储资源。为了在资源受限的环境中部署现代模型并加快推理时间，研究人员越来越多地探索</font>[<font style="color:rgb(9, 64, 142);">剪枝技术</font>](https://zhida.zhihu.com/search?content_id=242099111&content_type=Article&match_order=1&q=%E5%89%AA%E6%9E%9D%E6%8A%80%E6%9C%AF&zhida_source=entity)<font style="color:rgb(25, 27, 31);">。从2020年到2022年，每年发表超过千篇剪枝论文。然而，缺乏关于剪枝的最新综述论文。为了解决这个问题，在本次调查中，我们对深度</font>[<font style="color:rgb(9, 64, 142);">神经网络剪枝</font>](https://zhida.zhihu.com/search?content_id=242099111&content_type=Article&match_order=1&q=%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%89%AA%E6%9E%9D&zhida_source=entity)<font style="color:rgb(25, 27, 31);">的现有研究工作进行了全面回顾，包括</font>

1. <font style="color:rgb(25, 27, 31);">通用/特定加速</font>
2. <font style="color:rgb(25, 27, 31);">何时剪枝</font>
3. <font style="color:rgb(25, 27, 31);">如何剪枝</font>
4. <font style="color:rgb(25, 27, 31);">融合剪枝和其他压缩技术</font>

<font style="color:rgb(25, 27, 31);">然后，我们对剪枝设置了七对对比（例如，非结构化/结构化、一次性/迭代、无数据/数据驱动、初始化/预训练权重等）进行彻底的比较分析，并探索了几个新兴主题，包括</font>[<font style="color:rgb(9, 64, 142);">训练后剪枝</font>](https://zhida.zhihu.com/search?content_id=242099111&content_type=Article&match_order=1&q=%E8%AE%AD%E7%BB%83%E5%90%8E%E5%89%AA%E6%9E%9D&zhida_source=entity)<font style="color:rgb(25, 27, 31);">、不同监督级别的剪枝，以揭示现有方法的共性和差异，并为进一步的方法开发奠定基础。</font>

<font style="color:rgb(25, 27, 31);">最后，我们对选择剪枝方法提供了一些有价值的建议，并展望了神经网络剪枝的几个有前景的研究方向。</font>

<font style="color:rgb(25, 27, 31);">为了促进深度神经网络剪枝的未来研究，我们总结了广泛的剪枝应用（例如，对抗鲁棒性、自然语言理解等），并针对不同应用构建了数据集、网络和评估的精选集合。我们在 github 上维护一个存储库：</font>[https://github.com/hrcheng1066/awesome-pruning](https://link.zhihu.com/?target=https%3A//github.com/hrcheng1066/awesome-pruning)<font style="color:rgb(25, 27, 31);"> ，作为神经网络剪枝论文和相应开源代码的综合资源。我们将不断更新此存储库以包含该领域的最新进展。</font>

## <font style="color:rgb(25, 27, 31);"> 介绍</font>
<font style="color:rgb(25, 27, 31);">在过去的几年中，深度神经网络（DNN）在各个领域和应用中取得了显著的进展，例如计算机视觉（CV）、自然语言处理（NLP）和音频信号处理（ASP）等等。尽管 DNN 在各个领域取得了显著的成功，但其性能在很大程度上依赖于模型参数和计算成本。例如，广泛使用的</font>[<font style="color:rgb(9, 64, 142);">ResNet-50</font>](https://zhida.zhihu.com/search?content_id=242099111&content_type=Article&match_order=1&q=ResNet-50&zhida_source=entity)<font style="color:rgb(25, 27, 31);">需要超过95MB的内存用于存储，包含超过2300万个可训练参数，并且需要 4 GFLOP（千兆浮点运算）的计算。在 ImageNet 上训练的</font><font style="color:rgb(25, 27, 31);"> </font>[<font style="color:rgb(9, 64, 142);">VGG-16</font>](https://zhida.zhihu.com/search?content_id=242099111&content_type=Article&match_order=1&q=VGG-16&zhida_source=entity)<font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">大小超过 500 MB 。 基于 Transformer 架构的</font><font style="color:rgb(25, 27, 31);"> </font>[<font style="color:rgb(9, 64, 142);">GPT-3</font>](https://zhida.zhihu.com/search?content_id=242099111&content_type=Article&match_order=1&q=GPT-3&zhida_source=entity)<font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">模型由多达 1750 亿个参数组成 ，GPT-4 模型的参数甚至更多。目前扩大神经网络规模的趋势预计将持续下去。</font>

<font style="color:rgb(25, 27, 31);">然而，DNN 的参数越多，处理输入通常需要更多的时间和内存空间。与这些模型相关的高训练和推理成本对其在受有限计算资源（例如：CPU、GPU 和内存）、能源和带宽限制的设备上的部署提出了重大挑战。</font>

<font style="color:rgb(25, 27, 31);">例如，自动驾驶、野外救援和丛林火灾预防等现实应用需要高精度和高效的资源利用，包括快速的实时响应和紧凑的内存占用。深度神经网络的计算复杂性和内存占用使得它们在边缘设备上部署不切实际[14]。近年来，随着大语言模型的流行，人们对具有灵活硬件要求的计算机压缩神经网络越来越感兴趣[15]。此外，包含冗余特征的深度神经网络可能会破坏其鲁棒性，从而增加对抗性攻击的风险[16]。例如，这些网络创建的高维特征空间可以为对抗性攻击提供更大的入口点，从而削弱网络泛化到原始训练数据之外的能力。</font>

<font style="color:rgb(25, 27, 31);">为了缓解这个问题，研究人员提出了各种神经网络压缩技术来设计轻量级模型，包括神经网络剪枝（[17]）、权重矩阵的低秩分解（[18, 19]）、量化（[11, 20] ]）、知识蒸馏（[21]）、神经架构搜索（[22, 23]）和其他压缩技术（[24, 25]）。其中，人们对神经网络剪枝的研究持续感兴趣，它已被证明是一种理想且有效的方法，可以在推理时节省内存空间和计算时间，同时保持与神经网络相当甚至更好的性能。</font>

![](https://cdn.nlark.com/yuque/0/2025/png/2639475/1740118462749-e44c555d-b582-4e2b-bcfd-1881b06bf0ee.png)

<font style="color:rgb(145, 150, 161);">image.png</font>

<font style="color:rgb(25, 27, 31);">如图1所示，从2015年到2022年，关于剪枝的论文数量明显增加，占神经网络压缩的论文一半以上。</font>

<font style="color:rgb(25, 27, 31);">关于剪枝的研究早可以追溯到1988年的文献[26]。然而，直到[11]的出现，研究界才意识到剪枝在消除深度神经网络中显著冗余方面的潜力，剪枝开始受到广泛关注。有几篇文献回顾了深度神经网络剪枝的先前工作，如表 1 所示。尽管这些作品概述了剪枝的几个方面并为研究人员提供了有用的指导，但其中许多（[8,27,28,29] ）重点关注多种压缩技术，例如剪枝、量化和知识蒸馏，仅对每种技术进行简要检查。例如，米什拉等人[27]总结了压缩技术，包括剪枝、量化、低秩分解和知识蒸馏，其中剪枝主要是从通道/过滤器剪枝引入的，许多必要的剪枝技术（如彩票假设）并未包括在内。</font>

<font style="color:rgb(25, 27, 31);">一些综述工作（例如[30]）侧重于回顾卷积神经网络剪枝，而缺乏对其他深度神经网络（例如：循环神经网络（RNN））剪枝的描述。 [31]的工作对截至2020年深度学习的稀疏性进行了全面的回顾，但对新兴剪枝方法的研究很少，例如对比学习中的剪枝[32]和自监督剪枝[33]等。Wang等人[34]仅对初始化时的剪枝进行了概述，不包括对</font>[<font style="color:rgb(9, 64, 142);">训练期间剪枝</font>](https://zhida.zhihu.com/search?content_id=242099111&content_type=Article&match_order=1&q=%E8%AE%AD%E7%BB%83%E6%9C%9F%E9%97%B4%E5%89%AA%E6%9E%9D&zhida_source=entity)<font style="color:rgb(25, 27, 31);">、训练后剪枝等的研究。[35]是关于剪枝的最新调查，但仅关注</font>[<font style="color:rgb(9, 64, 142);">结构化剪枝</font>](https://zhida.zhihu.com/search?content_id=242099111&content_type=Article&match_order=1&q=%E7%BB%93%E6%9E%84%E5%8C%96%E5%89%AA%E6%9E%9D&zhida_source=entity)<font style="color:rgb(25, 27, 31);">。</font>

![](https://cdn.nlark.com/yuque/0/2025/png/2639475/1740118465896-409e4f80-81a7-43f8-b51a-d4ce5c61a2e2.png)

<font style="color:rgb(145, 150, 161);">image.png</font>

<font style="color:rgb(25, 27, 31);">这项调查旨在为不同的读者提供深度神经网络修剪的全面概述。我们回顾了代表性的剪枝方法，提出了一种新的分类法，对不同剪枝方式在实践中的表现进行了全面分析，并为希望利用剪枝的从业者提供了针对不同要求选择合适的剪枝方法的建议。我们的贡献如下：</font>

1. <font style="color:rgb(25, 27, 31);">综合审查。据我们所知，这项调查是对现代深度神经网络剪枝技术最全面的概述。它从 300 多篇相关学术论文中提炼出想法，并建立了一个新的分类法，如图2所示。此外，我们还提供了每类剪枝方法的代表性方法的详细描述。</font>
2. <font style="color:rgb(25, 27, 31);">对比实验与分析。我们对剪枝和最新进展进行了七对对比设置的比较分析。与现有的剪枝调查不同，本文进行了实验和相关讨论。</font>
3. <font style="color:rgb(25, 27, 31);">资源丰富。我们总结一下各种剪枝应用程序，并提供不同应用程序的基准数据集、网络和评估。我们在附录 B 中收集的资源可以指导研究人员和从业者理解、利用和开发满足不同需求的不同网络修剪方法。代表性修剪工作的持续更新可在 </font>[https://github.com/hrheng1066/awesome-pruning](https://link.zhihu.com/?target=https%3A//github.com/hrheng1066/awesome-pruning)<font style="color:rgb(25, 27, 31);"> 上找到。</font>
4. <font style="color:rgb(25, 27, 31);">建议和未来方向。本综述为针对不同应用需求选择合适的剪枝方法提供了宝贵的建议，并强调了有前景的未来研究方向。</font>

<font style="color:rgb(25, 27, 31);">本次调查的其余部分组织如下。</font>

<font style="color:rgb(25, 27, 31);">首先，在第 2 节中，我们解释常用术语并建立清晰的修剪分类法。第 3 - 6 节概述了加速、何时剪枝以及如何剪枝，然后在第 7 节中对不同类型的剪枝方法进行了全面的比较分析。第 8 节讨论了将剪枝与其他压缩方法集成。第 9 节提供了一些关于选择剪枝方法和未来方向的实用建议。我们在第 10 节中总结了本文。</font>

## <font style="color:rgb(25, 27, 31);"> 背景</font>
### <font style="color:rgb(25, 27, 31);">术语和符号</font>
<font style="color:rgb(25, 27, 31);">在本节中，我们首先列出本文中常用的术语和符号。那么本次调查的层次结构如图2所示。</font>

<font style="color:rgb(25, 27, 31);">以下小节介绍了剪枝文献中常用的术语。值得一提的是，一些术语（例如压缩比）在先前的作品中具有多种定义。然后我们提供不同文献中使用的几个定义。此外，为了更好的可读性，我们在表2中列出了本文使用的符号。</font>

![](https://cdn.nlark.com/yuque/0/2025/png/2639475/1740118465584-43d7461e-0153-4741-8d29-fd0fc146a3e6.png)

<font style="color:rgb(145, 150, 161);">image.png</font>

+ <font style="color:rgb(25, 27, 31);">剪枝率：剪枝率[38]表示从密集网络中删除的权重（或通道、滤波器、神经元等）的百分比。一般来说，可以通过两种方式确定：预先定义或学习决定。</font>
+ <font style="color:rgb(25, 27, 31);">压缩比：[39, 40]中的压缩比被定义为原始权重数与保留的权重数的比率，但在[41]中它被定义为保留的权重数与原始权重数的比率。例如，如果保留10%的权重，那么[40]中的压缩比是10，但在[41]中是10%。</font>
+ <font style="color:rgb(25, 27, 31);">稀疏率：稀疏率或稀疏度表示剪枝后网络中零权重（或通道、滤波器、神经元等）的部分[42, 43]。它等于[41]中的压缩比。</font>
+ <font style="color:rgb(25, 27, 31);">加速比：加速比定义为[12]中剪枝后的FLOP数或[44]中的MAC数除以原始FLOP数或MAC数。在[45]中，加速比是通过将一层中过滤器的剪枝数量除以该层中原始过滤器数量来计算的。</font>
+ <font style="color:rgb(25, 27, 31);">一次性剪枝：一次性剪枝，在[46]中也称为单次剪枝，仅评分一次，然后将网络剪枝到目标剪枝率[47, 48]。</font>
+ <font style="color:rgb(25, 27, 31);">迭代式剪枝：迭代式剪枝[10]，在[49]中也称为贪婪剪枝或预言剪枝，重复打分-剪枝-重新（score-prune-retrain）训练循环多轮，每一轮是一次迭代。</font>
+ <font style="color:rgb(25, 27, 31);">局部剪枝：局部剪枝通过将所有权重（或过滤器、通道等）细分为子集（例如层）然后删除每个子集的一定百分比来修剪网络[50]。</font>
+ <font style="color:rgb(25, 27, 31);">全局剪枝：与局部剪枝相反，全局剪枝从网络的所有可用结构中删除结构，直到达到特定的剪枝比率[50]。</font>
+ <font style="color:rgb(25, 27, 31);">动态剪枝：动态剪枝取决于特定的输入[51]，其中将为每个输入样本生成不同的子网络。</font>
+ <font style="color:rgb(25, 27, 31);">静态剪枝：与动态剪枝相反，静态剪枝的剪枝模型由不同样本共享[51]。换句话说，对于不同的输入，模型容量是固定的。</font>
+ <font style="color:rgb(25, 27, 31);">彩票假设：彩票假设（LTH）[47]指出随机初始化的密集网络f(x;w)包含稀疏子网络f(x;w⊙m)，该子网络可以用原始权重进行训练以实现竞争性与原始网络相比的性能。</font>
+ <font style="color:rgb(25, 27, 31);">中奖彩票：对于随机初始化的网络 f(x;w)，中奖彩票 f(x;w⊙m) 是其子网络，一旦经过 T epoch 的训练（即 f(x;w⊙m) 将匹配训练后网络 f(x; w) 在非平凡剪枝率下的性能[47]。</font>
+ <font style="color:rgb(25, 27, 31);">层坍塌：层坍塌是[39]中提到的一种现象，当网络某一层的所有权重被移除时就会发生这种现象。它使网络无法训练。哈尤等人[52]给出了这个问题的正式定义（即病态神经网络）。</font>
+ <font style="color:rgb(25, 27, 31);">权重倒带：权重倒带 [53] 将子网络的权重倒回到训练 w 中较早epoch的值，其中 t << T 。</font>
+ <font style="color:rgb(25, 27, 31);">学习率倒带：[40]中提出的学习率倒带，使用指定epoch数的学习率计划从最终值训练剩余的权重。</font>

### <font style="color:rgb(25, 27, 31);">分类</font>
<font style="color:rgb(25, 27, 31);">剪枝深度神经网络时存在三个关键问题。</font>

1. <font style="color:rgb(25, 27, 31);">通过神经网络剪枝得到通用加速还是特定加速？</font>
2. <font style="color:rgb(25, 27, 31);">什么时候对神经网络进行剪枝？ 具体来说，是神经网络在训练前、训练中还是训练后被静态修剪，还是动态(即运行时)修剪?</font>
3. <font style="color:rgb(25, 27, 31);">是按照特定标准进行剪枝还是基于学习进行剪枝？这三个问题的答案分别对应于深度神经网络剪枝的三个主要方面，如图2所示。</font>

![](https://cdn.nlark.com/yuque/0/2025/png/2639475/1740118465823-2123480f-c4e1-41a4-aaca-7f69fe948374.png)

<font style="color:rgb(145, 150, 161);">image.png</font>

<font style="color:rgb(25, 27, 31);">第一个问题是加速是否取决于特定的硬件/软件。它通常分为三种类型：非结构化（[39,46,47]）、半结构化（也称为基于模式）（[54,55,56]）和结构化（[57,58,59]）。只有结构化剪枝才能实现通用的神经网络加速和压缩，而不需要特殊的硬件或软件。相反，非结构化和</font>[<font style="color:rgb(9, 64, 142);">半结构化剪枝</font>](https://zhida.zhihu.com/search?content_id=242099111&content_type=Article&match_order=1&q=%E5%8D%8A%E7%BB%93%E6%9E%84%E5%8C%96%E5%89%AA%E6%9E%9D&zhida_source=entity)<font style="color:rgb(25, 27, 31);">都需要特殊硬件或软件的支持。</font>

<font style="color:rgb(25, 27, 31);">第二个问题特别指出静态剪枝的神经网络剪枝权重和训练权重之间的安排。根据剪枝是在网络训练之前、期间还是之后进行，静态剪枝安排可以分为三类：</font>[<font style="color:rgb(9, 64, 142);">训练前剪枝</font>](https://zhida.zhihu.com/search?content_id=242099111&content_type=Article&match_order=1&q=%E8%AE%AD%E7%BB%83%E5%89%8D%E5%89%AA%E6%9E%9D&zhida_source=entity)<font style="color:rgb(25, 27, 31);">（PBT）（[39,46,52,60,61]），训练期间剪枝（ PDT）（[62,63,64]），以及训练后剪枝（PAT）（[47,65,66,67]）。在动态修剪中，在运行时为每个输入数据点生成子网络。</font>

<font style="color:rgb(25, 27, 31);">第三个问题考虑是否使用特定标准或通过学习来修剪神经网络。 标准依赖于启发式公式来衡量每个权重（或过滤器、通道等）的重要性。</font>

<font style="color:rgb(25, 27, 31);">常用的剪枝准则包括幅度、范数、损失变化等。此外，还可以通过学习来对神经网络进行剪枝，比如：通过</font>[<font style="color:rgb(9, 64, 142);">稀疏正则化</font>](https://zhida.zhihu.com/search?content_id=242099111&content_type=Article&match_order=1&q=%E7%A8%80%E7%96%8F%E6%AD%A3%E5%88%99%E5%8C%96&zhida_source=entity)<font style="color:rgb(25, 27, 31);">训练或动态稀疏训练进行剪枝[68]等。无论是通过特定标准还是学习，剪枝的目的是确定应剪枝的网络权重。</font>

<font style="color:rgb(25, 27, 31);">以上三个方面决定了剪枝算法的主要特征。这三个方面的不同组合就形成了不同的修剪方法。我们在第 3 到 6 节和第 8 节中提供了深度神经网络剪枝的新分类法，如图 2 所示。</font>

## <font style="color:rgb(25, 27, 31);">特定或通用加速</font>
<font style="color:rgb(25, 27, 31);">本节将深度神经网络剪枝分为非结构化、半结构化和结构化。前两种类型对应于特定加速比，第三种对应于通用加速比。下面我们对每个类别进行详细的介绍。</font>

### [<font style="color:rgb(9, 64, 142);">非结构化剪枝</font>](https://zhida.zhihu.com/search?content_id=242099111&content_type=Article&match_order=1&q=%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E5%89%AA%E6%9E%9D&zhida_source=entity)
<font style="color:rgb(25, 27, 31);">非结构化剪枝，也称为非结构化剪枝或权重剪枝，是最细粒度的情况。</font>

<font style="color:rgb(25, 27, 31);">定义 1（非结构化修剪）。给定神经网络权重 </font>`<font style="color:rgb(25, 27, 31);">\mathbf{w}={w_0,w_1,...,w_K} ，由输入 (x)、输出 (y) 对组成的数据集 \mathcal{D} = \{ ( \mathbf{x}_i, \mathbf{y}_i) \}_{i=1}^{N} </font>`<font style="color:rgb(25, 27, 31);">，和所需的非零权重k，非结构化剪枝可以写成以下约束优化问题[46]：</font>

```yaml
\mathop{\textrm{min}} \limits_{\mathbf{w}} \mathcal{L}(\mathbf{w};\mathcal{D}) = \mathop{\textrm{min}}\limits_{\mathbf{w}} \frac{1}{N}\sum_{i=1}^N\ell(\mathbf{w};(\mathbf{x}_i,\mathbf{y}_i)) \\\textrm{s.t.} \ \lVert \mathbf{w}\rVert_0 \leq k \\

```

<font style="color:rgb(25, 27, 31);">在实践中，非结构化剪枝通常不会直接将权重设置为0，而是将其相应的掩码（或指标）m设置为0[46, 61]。在这种情况下，非结构化剪枝被视为对每个权重应用二进制掩码。则式（1）相应修改为：</font>

```yaml
\mathop{\textrm{min}}\limits_{\mathbf{w,m}} \ \mathcal{L}(\mathbf{w}\odot \mathbf{m};\mathcal{D}) = \mathop{\textrm{min}}\limits_{\mathbf{w,m}} \frac{1}{N}\sum_{i=1}^N\ell(\mathbf{w}\odot \mathbf{m};(\mathbf{x}_i.\mathbf{y}_i)) \\\textrm{s.t.} \ \lVert \mathbf{m}\rVert_0 \leq k. \\
```

<font style="color:rgb(25, 27, 31);">通常，网络使用固定掩码 m 进行重新训练（即微调或从头开始训练），并且掩码权重不参与重新训练。图3是通过删除神经元的连接（如图3（a）所示）或用相应的掩码屏蔽权重（如图3（b）所示）进行权值剪枝。</font>

![](https://cdn.nlark.com/yuque/0/2025/png/2639475/1740118466009-e54629e9-b18f-4105-8385-3a0c169afc33.png)

<font style="color:rgb(145, 150, 161);">image.png</font>

<font style="color:rgb(25, 27, 31);">由于它可以去除任何地方的权重，非零权重的不规则替换导致实际加速需要特殊软件或硬件的支持[11,51,63,69,70]。因此，我们将非结构化剪枝归类为一种特定的加速技术。</font>

### <font style="color:rgb(25, 27, 31);">结构化修剪</font>
<font style="color:rgb(25, 27, 31);">定义 2（结构化修剪）。给定特定的剪枝比例和具有</font>`<font style="color:rgb(25, 27, 31);"> S={s_1, s_2, ..., s_L}</font>`<font style="color:rgb(25, 27, 31);">的神经网络，其中，</font>`<font style="color:rgb(25, 27, 31);">s_i</font>`<font style="color:rgb(25, 27, 31);"> 是第 </font>`<font style="color:rgb(25, 27, 31);">i</font>`<font style="color:rgb(25, 27, 31);"> 层中的通道、滤波器或神经元的集合。</font>

<font style="color:rgb(25, 27, 31);">结构化剪枝的目的是在给定剪枝比率下搜索</font>`<font style="color:rgb(25, 27, 31);"> S^{'}=\{s_1^{'}, s_2^{'}, ..., s_L^{'}\} </font>`<font style="color:rgb(25, 27, 31);">以最小化性能退化并最大化速度提升，其中</font>`<font style="color:rgb(25, 27, 31);"> s_i^{'}\subseteq s_i, i\in \{1,.., L\} </font>`<font style="color:rgb(25, 27, 31);">。</font>

<font style="color:rgb(25, 27, 31);">结构化剪枝删除了整个过滤器、通道、神经元甚至层（[64]），如图 4（b）所示，并且可以重建具有规则结构的狭窄模型。它不需要特殊硬件和软件（例如稀疏卷积库）的支持，可以直接加速网络并减小神经网络的大小</font>`<font style="color:rgb(25, 27, 31);">[14,50,69,71]</font>`<font style="color:rgb(25, 27, 31);">。此外，滤波器和通道剪枝可以认为是等效的，因为剪枝第i层中的滤波器相当于剪枝第</font>`<font style="color:rgb(25, 27, 31);">i+1</font>`<font style="color:rgb(25, 27, 31);">层中的相应通道[72]，如图4（a）所示。</font>

![](https://cdn.nlark.com/yuque/0/2025/png/2639475/1740118465904-c550ce2d-cd5f-4549-a3fc-0d1669fc5370.png)

<font style="color:rgb(145, 150, 161);">image.png</font>

### <font style="color:rgb(25, 27, 31);">半结构化剪枝</font>
<font style="color:rgb(25, 27, 31);">为了提高结构化剪枝的灵活性并在剪枝率较高时实现较低的精度下降，一些最近的工作（[55, 56]）引入了半结构化剪枝，在[56]中被称为基于模式的剪枝，以同时实现高精度和结构规律性。可设计各种模式；一些例子如图4(c)所示。相反，全结构化剪枝（例如：通道或过滤器剪枝）被归类为粗粒度结构化剪枝（[55,56,73]），而半结构化剪枝被归类为细粒度结构化剪枝。例如，孟等人 [74]将一个过滤器视为多个stripes，并建议修剪每个过滤器中的stripes。然而，用于半结构化剪枝的模式需要仔细设计，以减轻性能下降并像非结构化剪枝一样进行特定的加速。</font>

## <font style="color:rgb(25, 27, 31);">何时进行剪枝</font>
<font style="color:rgb(25, 27, 31);">本节将区分静态剪枝（如图 5 所示）的三种剪枝流水线和运行时剪枝。静态剪枝的三种流水线的示例如图6所示。静态剪枝的三种流水线的剪枝文献统计如图12所示。</font>

![](https://cdn.nlark.com/yuque/0/2025/png/2639475/1740118467221-6d75b326-abba-415e-a5e5-ba05f5472e1f.png)

<font style="color:rgb(145, 150, 161);">image.png</font>

![](https://cdn.nlark.com/yuque/0/2025/png/2639475/1740118467121-f21a66c1-7fa4-4f5d-9b03-884b31259cb6.png)

<font style="color:rgb(145, 150, 161);">image.png</font>

![](https://cdn.nlark.com/yuque/0/2025/png/2639475/1740118467069-519eb40d-9a12-4117-83f4-5f0b63e9a4a8.png)

<font style="color:rgb(145, 150, 161);">image.png</font>

### <font style="color:rgb(25, 27, 31);">训练前修剪</font>
<font style="color:rgb(25, 27, 31);">训练前剪枝（PBT），也称为预见剪枝[61]或初始化剪枝[39, 46]，代表一类使用随机初始化权重来剪枝网络的剪枝方法。</font>

<font style="color:rgb(25, 27, 31);">PBT 方法的主要动机是消除预训练的成本。我们将神经网络定义为函数 </font>`<font style="color:rgb(25, 27, 31);">f(\mathbf{x};\mathbf{w}\odot \mathbf{m})</font>`<font style="color:rgb(25, 27, 31);">。掩码 m 用于修剪从特定初始化分布采样的初始化权重 w。剪枝后，网络 </font>`<font style="color:rgb(25, 27, 31);">f(\mathbf{x};\mathbf{w}_{0} \odot \mathbf{m}^{'}) </font>`<font style="color:rgb(25, 27, 31);">被训练为在 T 个 epoch 后收敛 </font>`<font style="color:rgb(25, 27, 31);">f(\mathbf{x};\mathbf{w}_{T} \odot \mathbf{m}^{'})</font>`<font style="color:rgb(25, 27, 31);">，其中，</font>`<font style="color:rgb(25, 27, 31);">\mathbf{m}^{'}</font>`<font style="color:rgb(25, 27, 31);">表示剪枝后的稀疏性结果。</font>

<font style="color:rgb(25, 27, 31);">PBT通常遵循两阶段：根据特定标准直接修剪未经训练的密集网络，然后训练稀疏网络至收敛以获得高性能，如图5（a）所示。第二步与静态稀疏训练[75]相关，旨在在训练期间训练具有固定稀疏模式的稀疏网络。由于避免了耗时的预训练过程，PBT 方法在训练和推理时间上带来了相同的收益。</font>

<font style="color:rgb(25, 27, 31);">李等人[46]开创了PBT的研究，并提出了单次网络剪枝（SNIP）方法来去除那些缺失导致损失变化最轻微的权重。在[77]中，作者通过信号传播解释了 SNIP 的可行性，凭经验发现剪枝会损害神经网络的动态等距性[78]，并提出一种无数据正交初始化（精确等距性的近似）来剪枝随机网络。与[77]中关注初始化方案的信号传播视角不同，Wang 等人[61]提出梯度信号保留（GraSP）方法，利用剪枝后的梯度范数对剪枝后对梯度流影响最小的权重进行剪枝。田中等人[39]更进一步指出，无需训练和查看数据即可识别有效的子网络。</font>

<font style="color:rgb(25, 27, 31);">他们提出了一种称为迭代Synaptic流修剪（SynFlow）的无数据修剪算法，该算法使用Synaptic流的概念来考虑不同层的相互作用，并通过逐步修剪避免层崩溃。除了数据不可知之外，Su等人[60]观察到修剪的结构对于最终性能并不重要。他们提出了一种零样本无数据修剪方法，使用一系列分层保持比率（即智能比率）随机剪枝每一层。格布哈特等人[79]利用基于神经正切核[80]的路径核（即网络中路径值的协方差）在单一框架下统一几种初始化剪枝方法，例如：SNIP[46]、CraSP[61]、SynFlow[39] 。</font>

<font style="color:rgb(25, 27, 31);">周等人[81]观察到，当权重随机初始化和固定时，未经训练的网络在使用精心选择的掩码的 MNIST 上可以达到近 40% 的准确率。他们认为，虽然密集网络是随机初始化的，但对子网络的搜索可以作为一种训练。由 Ramanujan 等人 [81] 催化并受到权重不可知神经网络 (WANN) [82] 的启发。 [83]凭经验发现，随着未经训练的网络变得更宽更深，它将包含一个子网络，其性能与具有相同数量参数的训练网络相同。然后他们提出了 edge-popup 方法来寻找这种随机初始化的子网络。与edge-popup 方法不同的是，Bai 等人从不改变权重值。 [65]提出了双重彩票假设（DLTH），其中子网络和权重在初始化时都是随机选择的，并提出了随机稀疏网络变换（RST），它修复了稀疏架构，逐渐训练剩余的权重。</font>

<font style="color:rgb(25, 27, 31);">最近的一些工作探讨了为什么我们可以在初始化时识别有效的子网络，而不是依赖于预训练的权重。王等人[76]凭经验发现，直接从随机初始化的权重中进行剪枝可以发现更加多样化和有效的剪枝结构。相反，从预训练权重中发现的修剪结构往往是同质的，这阻碍了寻找更好的模型。</font>

<font style="color:rgb(25, 27, 31);">刘等人[75]凭经验证明，网络大小和适当的分层剪枝比率是从头开始初始化随机剪枝网络以匹配密集模型性能的两个重要因素。例如，他们发现随机剪枝很难在小型网络（例如 ResNet-20 和 ResNet-32）上找到匹配的子网络，即使剪枝比率适中（即 10%、20%）。然而，随机剪枝可以在 60%-70% 的剪枝率下与大型网络（例如： ResNet-56 和 ResNet-110）的密集性能相匹配。</font>

### <font style="color:rgb(25, 27, 31);">训练期间的修剪</font>
<font style="color:rgb(25, 27, 31);">训练期间剪枝（PDT）一般以随机初始化的密集网络</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">f(\mathbf{x};\mathbf{w}_{0})</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">作为输入模型，通过在训练期间更新权重w和权重（或滤波器、通道）的掩码m来联合训练和剪枝神经网络。这些动态方案改变掩码并在 t 次迭代/历元后得到子网络</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">f(\mathbf{x};\mathbf{w}_{t} \odot \mathbf{m}_{t})</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">。剪枝后，许多 PDT 方法（[64、84、85、86、87]）直接获得子网络，不再需要从头开始训练或微调过程。 PDT的典型流程如图5（b）所示，其中虚线箭头所示的过程是可选的。</font>

<font style="color:rgb(25, 27, 31);">与PBT和PAT方法相比，PDT方法的动态过程更为复杂，因此对其研究较少。我们将现有的主要解决方案总结为三个范式：</font>

<font style="color:rgb(25, 27, 31);">（1）基于稀疏正则化 （2）基于动态稀疏训练 （3）基于分数</font>

<font style="color:rgb(25, 27, 31);">与(1)或(3)相关的方法进行从稠密到稀疏的训练，与(2)相关的方法进行稀疏到稀疏的训练。</font>

### <font style="color:rgb(25, 27, 31);">基于稀疏正则化的方法</font>
<font style="color:rgb(25, 27, 31);">稀疏正则化技术常用于 PDT 方法 ([74, 88])。这类方法从稠密网络开始，对损失函数施加稀疏约束，并且通常在训练期间将一些权重或其掩码归零。</font>

<font style="color:rgb(25, 27, 31);">主要工作是设计具有先进惩罚方案和高效优化算法的有效目标损失函数L。例如，文等人[63]提出结构化稀疏学习（SSL），在训练期间通过组 LASSO [89]正则化来学习稀疏结构。然而，SSL 要求计算正则化项与所有权重之间的梯度，这并非易事。戈登等人[90]提出MorphNet，重用BN的参数并对这些参数进行稀疏正则化。然而，一些网络（例如，一些 VGGNet [2]）没有 BN 层。而不是重用BN参数一些工作将缩放因子与通道、滤波器、层等相关联。例如，Huang 和 Wang [64] 提出稀疏结构选择（SSS），它将 CNN 微结构（例如：通道、残差块）的缩放因子相关联并利用稀疏性正则化迫使微结构的输出为零，而不是在[63]中将同一组中的权重推为零。此外，SSS 不需要[63]中所需的额外微调。李等人[91]提出了分解卷积滤波器（FCF），它向每个滤波器引入了一个二进制标量，并提出了一种使用交替方向乘数法（ADMM）[92]算法进行反向传播，以在训练期间联合训练权重和标量。</font>

### <font style="color:rgb(25, 27, 31);">基于动态稀疏训练的方法</font>
<font style="color:rgb(25, 27, 31);">一类 PDT 方法（[84,93,94,95,96,97,98]）采用随机初始化的稀疏网络而不是稠密网络作为输入模型。随后，一种常见的方法是修剪一小部分不重要的权重，然后重新增长相同数量的新权重以调整稀疏架构。这种方法通过在训练过程中重复剪枝-生长循环，不断寻找更好的稀疏架构，在文献[84]中被归类为动态稀疏训练。。</font>

<font style="color:rgb(25, 27, 31);">例如，莫卡努等人[93]提出稀疏进化训练（SET），删除最小的正权重和最大的负权重，并在随机位置增加新的权重。 Mostafa 和 Wang [95] 提出了动态稀疏重新参数化（DSR），它使用自适应阈值进行修剪，而不是在每个重新分配步骤中修剪固定比例的权重，例如 SET [93]。此外，DSR[95]跨层重新分配权重，并且不限于SET[93]中的内层权重重新分配。刘等人[99]提出了一种集成方法 FreeTickets，它集成了由稀疏到稀疏方法创建的稀疏子网络。</font>

<font style="color:rgb(25, 27, 31);">Dai 等人没有使用随机再生方案。 [94]提出了一种 DNN 综合工具（NeST），该工具使用小型网络进行训练，通过基于梯度的增长和基于幅度的修剪来调整子网络。埃夫齐等人[84]提出 Rigged Lottery (RigL)，它在训练期间使用梯度幅度激活新连接。同样，刘等人[96]提出了零成本神经再生的渐进剪枝（GraNet），以根据网络的权重大小删除网络的连接，并根据网络的梯度重新生长网络的连接。他们认为，即使梯度值为零的权重也表明了连接的重要性。索卡等人 [100] 是探索强化学习（RL）动态稀疏训练的先驱。格雷瑟等人[101]系统地研究了RL中的一些动态稀疏训练方法（例如：RigL [84]，SET [93]）。</font>

<font style="color:rgb(25, 27, 31);">埃夫齐等人[102]分析了动态稀疏训练的合理性。作者发现稀疏网络在初始化时梯度流很差，但动态稀疏训练显著改善了梯度流。这可能是他们成功的原因。</font>

### <font style="color:rgb(25, 27, 31);">基于分数的方法</font>
<font style="color:rgb(25, 27, 31);">一些 PDT 方法利用评分标准在训练期间剪枝网络。He等人[86]提出了</font>**<font style="color:rgb(25, 27, 31);">软滤波器剪枝（SFP）</font>**<font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">的滤波器剪枝方法，该方法可以从头开始训练网络，并通过使用每个滤波器的L2范数（L2 Norm）作为其重要性来同时剪枝网络。他们没有将掩码与过滤器关联起来，而是直接将修剪后的过滤器权重设置为零，可以通过前向-后向过程从零更新。因此，该epoch的剪枝过滤器可以在下一个epoch恢复。然而，SFP需要手动预设每层的修剪比率。He 等人 [103] 提出通过几何中值（FPGM）进行滤波器修剪，以修剪最接近同一层内滤波器的几何中值[104]的冗余滤波器。然而，FPGM 还要求每层都有一个预定义的剪枝比率。刘等人[62]提出了一种称为 Network Slimming 的方法，该方法为每个通道引入一个缩放因子，并通过在因子上添加稀疏正则化的常规损失</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">\ell</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">来联合训练权重和缩放因子，并将这些缩放因子的大小用作过滤分数。在实践中，他们直接重用批量归一化（BN）[105]层中的</font><font style="color:rgb(25, 27, 31);">\gamma</font><font style="color:rgb(25, 27, 31);">参数作为缩放因子。</font>

### <font style="color:rgb(25, 27, 31);">训练后修剪</font>
<font style="color:rgb(25, 27, 31);">训练后剪枝（PAT）是最流行的剪枝流水线类型，因为人们普遍认为预训练密集网络对于获得有效的子网络是必要的[38]。这类剪枝方法通常遵循预训练-剪枝-再训练过程，如图 5 (c) 所示。</font>

1. <font style="color:rgb(25, 27, 31);">预训练随机初始化的密集网络 </font>`<font style="color:rgb(25, 27, 31);">f(\mathbf{x};\mathbf{w}_{0})以收敛 f(\mathbf{x};\mathbf{w}_{T})</font>`<font style="color:rgb(25, 27, 31);">。</font>
2. <font style="color:rgb(25, 27, 31);"> 修剪权重（或对性能影响最小的过滤器、神经元等）并对剪枝后的网络 </font>`<font style="color:rgb(25, 27, 31);">f(\mathbf{x};\mathbf{w}_{T}^{'} \odot \mathbf{m}^{'})</font>`<font style="color:rgb(25, 27, 31);"> 进行多次迭代微调，其中</font>`<font style="color:rgb(25, 27, 31);"> \mathbf{w}_{T}^{'} </font>`<font style="color:rgb(25, 27, 31);">和 </font>`<font style="color:rgb(25, 27, 31);">\mathbf{m}^{'} </font>`<font style="color:rgb(25, 27, 31);">分别是剪枝后的权重和掩码。过程（2）至少被处理一次（即，一次性剪枝）或多次（即，迭代剪枝）。</font>
3. <font style="color:rgb(25, 27, 31);">从头开始训练剩余的权重</font>`<font style="color:rgb(25, 27, 31);">f(\mathbf{x};\mathbf{w}_{0} \odot \mathbf{m}^{''})</font>`<font style="color:rgb(25, 27, 31);">或微调 </font>`<font style="color:rgb(25, 27, 31);">f(\mathbf{x};\mathbf{w}_{T}^{''} \odot \mathbf{m}^{''})</font>`<font style="color:rgb(25, 27, 31);"> 以恢复性能[40]，其中，</font>`<font style="color:rgb(25, 27, 31);">\mathbf{w}_{T}^{''} </font>`<font style="color:rgb(25, 27, 31);">和</font>`<font style="color:rgb(25, 27, 31);"> \mathbf{m}^{''} </font>`<font style="color:rgb(25, 27, 31);">权重和掩码经过整体剪枝后的最终结果。在剪枝过程中，稀疏度逐渐增加，直至达到目标。</font>

### <font style="color:rgb(25, 27, 31);">LTH 及其变体</font>
<font style="color:rgb(25, 27, 31);">彩票假设（LTH）[47]是神经网络剪枝领域最有影响力的假设之一。给定一个预训练的网络，LTH 会根据权重的大小迭代地删除一定百分比的权重。修剪后，剩余的权重从头开始重新训练原始初始化，而不是随机重新初始化，以匹配原始网络的准确性。</font>

<font style="color:rgb(25, 27, 31);">它挑战了人们普遍认为必须使用预训练权重进行再训练的范式，并推测稠密网络中是否存在可独立训练的稀疏子网络。受 LTH 的启发，有各种后续工作来识别更广泛的彩票并更好地理解 LTH，可分为四个主要类别：（1）提出更强的彩票假设，（2）探索 LTH 的可迁移性，（3 ）将 LTH 推广到其他环境，（4）理论论证，以及（5）重新审视和质疑 LTH。</font>

1. <font style="color:rgb(25, 27, 31);">最近的一些著作 ([106, 107, 108]) 证明了比 LTH [47] 更强的假设。例如，Diffenderfer 和 Kailkhura [108] 提出了一种更强的 Multi-Prize LTH，它声称中奖彩票对于极端形式的量化（即二值权重和/或激活）具有鲁棒性。基于此，他们提出了一种多奖票（MPT）算法，首次在二元神经网络上查找 MPT。</font>
2. <font style="color:rgb(25, 27, 31);">一些文献 ([67, 109, 110, 111]) 研究了源数据集中发现的中奖彩票到另一个数据集的可转移性，这提供了对 LTH 可转移性的见解。例如，S. Morcos 等人[109] 发现 OneTicket 可以泛化自然图像领域内的各种数据集和优化器。 Mehta [110] 提出了票转移假设，并针对不同的图像分类数据集转移中奖票。</font>
3. <font style="color:rgb(25, 27, 31);">除了图像分类之外，LTH 还扩展到许多其他上下文，例如：节点分类和链接预测（[67]）以及视觉和语言（[111]）。例如，陈等人 [67] 是将 LTH 推广到图神经网络（GNN）[112] 的先驱，并提出了图彩票（GLT）。</font>
4. <font style="color:rgb(25, 27, 31);">一方面，一些文献([117, 118])分析了LTH[47]能够获胜的原因。例如，张等人 [117] 利用动力系统理论和惯性流形从理论上验证了LTH的有效性。埃夫齐等人[102]观察到LTH的成功在于有效地重新学习它们所导出的原始剪枝解决方案。张等人[118] 率先为从 LTH 实验结果中观察到的中奖彩票的改进泛化提供了正式的理由。</font>
5. <font style="color:rgb(25, 27, 31);">另一方面，最近的一些著作（[38,119,120]）重新审视并挑战了LTH的存在。例如，马等人[119]提供了更严格的LTH定义，用于精确识别中奖彩票，并发现是否以及何时可以识别中奖彩票很大程度上依赖于训练设置，例如学习率、训练eopch和架构特征，例如：网络容量和残余连接。使用较小的学习率或不足的训练周eopch更有可能找到中奖彩票。</font>

<font style="color:rgb(25, 27, 31);">值得指出的是，在一些著作[16, 34]中，LTH[47]被归类为PBT方法。然而，LTH 基于预训练网络选择掩码，这不符合 PBT 在训练前尝试修剪初始化网络的定义。因此，将LTH归类为PAT方法更为合理。</font>

### <font style="color:rgb(25, 27, 31);">其他基于分数的方法</font>
<font style="color:rgb(25, 27, 31);">选择修剪候选者的最直接和直观的方法是根据它们的范数对其进行评估。例如，韩等人[11]提出通过其绝对值来衡量权重重要性。李等人[69]通过计算其权重‘</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">l_{1}</font><font style="color:rgb(25, 27, 31);">-范数之和来对每层中的每个过滤器进行评分。除了基于范数的标准之外，评估有或没有权重的损失变化也很受欢迎。例如，Nonnenmacher 等人[50]提出二阶结构化修剪（SOSP）来选择性地将滤波器掩码清零，以最大限度地减少删除某些滤波器造成的损失变化的影响。歧视感知通道修剪（DCP）[121]通过最小化联合损失（包括常规损失和歧视感知损失）来选择最具辨别力的通道。许多作品（[14,58,113,116]）评估每层局部权重（或过滤器、神经元等）的重要性。这些方法的主要缺点是局部排序使得很难确定整体最佳稀疏性，并且每层的预定义剪枝率可能不重要且次优。一些作品（[43,122,123]）被提出来解决这个问题。例如，Chin 等人[122]提出学习全局排名（LeGR）来学习跨层全局过滤器排名。刘等人[71]提出Group Fisher Pruning（GFP）应用Fisher信息来评估单个通道和耦合通道的重要性。</font>

### <font style="color:rgb(25, 27, 31);">基于稀疏正则化的方法</font>
<font style="color:rgb(25, 27, 31);">一些工作（[115,124,125,126]）利用稀疏正则化技术。例如，何等人 [124] 提出了一种替代的两步算法，该算法向预训练的 CNN 模型的每个通道引入标量掩码，并基于 LASSO 回归选择冗余通道[127]，并使用线性最小二乘法用未剪枝的通道重建输出。能量约束压缩（ECC）[128]通过双线性回归函数构建能量消耗模型。通过性能最大化(NPPM)进行网络修剪[129]训练了一个性能预测网络，并将其作为准确率的代理来指导基于正则化惩罚的子网搜索。方等人[44]开发了一种称为 DepGraph 的通用方法来分析各种网络结构（例如：CNN、RNN、GNN、Transformers）的依赖性，并提出基于稀疏正则化的结构化剪枝。一些方法（[44,58,113,116]）通过结合基于范数的标准和稀疏正则化来选择重要的权重（或过滤器、神经元等）。</font>

### <font style="color:rgb(25, 27, 31);">早期训练中的修剪</font>
<font style="color:rgb(25, 27, 31);">此类方法不是完全训练从</font><font style="color:rgb(25, 27, 31);">f(\mathbf{x};\mathbf{w}_{0})</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">到</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">f(\mathbf{x};\mathbf{w}_{T})</font><font style="color:rgb(25, 27, 31);">的网络，而是通过仅训练网络几次迭代或 epoch 来探索网络架构，即</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">f(\mathbf{x};\mathbf{w}_{t})</font><font style="color:rgb(25, 27, 31);">，其中 $t<</font>

### <font style="color:rgb(25, 27, 31);">训练后剪枝</font>
<font style="color:rgb(25, 27, 31);">与遵循预训练-剪枝-再训练过程的一般 PAT 方法相比，最近提出的训练后剪枝将三步过程简化为预训练-剪枝。它涉及在不重新训练的情况下修剪预训练的模型</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">f(\textbf{x};\textbf{w}_{T})</font><font style="color:rgb(25, 27, 31);">，精度损失可以忽略不计。这类剪枝方法对于十亿参数模型特别有吸引力，因为剪枝后重新训练此类剪枝模型仍然非常昂贵。</font>

<font style="color:rgb(25, 27, 31);">例如，Frantar 和 Alistarh [15] 提出了一种称为 SparseGPT 的非结构化训练后剪枝方法。通过将剪枝问题简化为近似稀疏性回归，作者将 GPT 系列模型剪枝为至少 50% 的稀疏度，且精度损失较小，无需重新训练。据我们所知，这是第一个专门为 GPT 系列模型设计的剪枝方法。Kwon等人 [133]提出了 Transformers 的结构化训练后剪枝框架，包括三个步骤：基于 Fisher 的掩模搜索、基于 Fisher 的掩模重排和掩模调整。无需重新训练，该框架可以在 3 分钟内修剪一个 GPU 上的 Transformer。</font>

### <font style="color:rgb(25, 27, 31);">运行时修剪</font>
<font style="color:rgb(25, 27, 31);">先前的剪枝工作通常集中于静态剪枝方法，剪枝后的模型可重复用于不同的输入。相反，一些方法根据各个输入动态地修剪神经网络，即运行时修剪[134]。</font>

<font style="color:rgb(25, 27, 31);">这项工作的前提是，对于给定的任务，产生准确输出的难度可能会有所不同，这意味着不同输入的模型能力的必要性是不同的[51]。</font>

<font style="color:rgb(25, 27, 31);">例如，Rao 等人[134]提出了一种运行时网络路由（RNR）框架，根据输入图像和当前特征图进行动态路由，并选择最佳路径子集进行压缩。Tang 等人[51]指出通道的重要性很大程度上取决于输入数据，并建议为每个实例生成不同的子网络。推理时，仅需要计算显著性大于阈值的通道，并跳过冗余特征。Hua 等人[135]利用输入特定的特征，并提出 CGNet 通过对输入通道的子集执行卷积，通过输出激活的部分和来预测不重要区域。Gao 等人[136]提出特征增强和抑制（FBS）来预测通道的显著性，并跳过那些在运行时对分类结果贡献较小的通道。 Fire Together Wire Together [33]将动态模型剪枝视为一个自监督的二元分类问题。孟等人[137]提出Contrastive Dual Gating（CDG），这是另一种使用对比学习的自监督动态剪枝方法[138]。</font>

## <font style="color:rgb(25, 27, 31);">修剪标准</font>
<font style="color:rgb(25, 27, 31);">在本节中，我们总结了一些常用的剪枝标准，这些标准用于从不同角度评估权重（或过滤器、神经元等）的重要性，包括幅度（[10, 139, 140, 141]）、范数（[ 69, 86]），显著性和/或敏感性（[85, 142, 143]），损失变化（[13, 50, 71, 142, 144]）。这些标准之间没有严格的界限，但侧重点不同。</font>

### <font style="color:rgb(25, 27, 31);">基于幅度的剪枝</font>
<font style="color:rgb(25, 27, 31);">[26] 是提出基于幅度的剪枝以减少隐藏单元的最早的作品之一。韩等人[11] 推广到深度神经网络基于幅度的剪枝，剪枝最低幅度的权重。它基于这样的假设：绝对值较小的权重往往对网络输出的影响最小。该公式定义为</font>

`<font style="color:rgb(25, 27, 31);">m_i = \begin{cases} 1: if \ \lVert w_i \rVert_{1} \ge a\\ 0: if \ \lVert w_i \rVert_{1} < a \end{cases} \\</font>`

<font style="color:rgb(25, 27, 31);">其中，</font><font style="color:rgb(25, 27, 31);">a</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">是阈值。</font>

<font style="color:rgb(25, 27, 31);">基于幅度的标准可以应用于非结构化（[10,47,139,145,146,147]）或结构化剪枝（[69,94,148]）。例如，李等人[69]通过计算权重绝对值的总和来对滤波器进行评分。此外，基于幅度的标准可以与全局/局部、一次性/迭代schedules相结合。例如，[149]和[150]中的工作提出了基于幅度的迭代全局剪枝方法。 Singh Lubana 和 P. Dick [140] 认为基于幅度的剪枝比与幅度无关的方法会更快的模型收敛。</font>

### <font style="color:rgb(25, 27, 31);"> l_p 范数</font>
<font style="color:rgb(25, 27, 31);">一些方法（[69, 86]）使用</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">l_p</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">范数来评估权重（或过滤器、通道等）的重要性。例如，he 等人[86]利用</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">l_p</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">范数来评估滤波器</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">\mathcal{F}_{i,j}</font><font style="color:rgb(25, 27, 31);">的重要性。</font>

`<font style="color:rgb(25, 27, 31);">\lVert \mathcal{F}_{i,j} \rVert_{p}=\left(\sum_{n=1}^{c_{in}^{(i)}}\sum_{k_1=1}^{k^{(i)}}\sum_{k_2=1}^{k^{(i)}}\left | \mathcal{F}_{i,j}(n,k_1,k_2)\right |^p \right)^{\frac{1}{p}} \\</font>`

<font style="color:rgb(25, 27, 31);">其中，</font><font style="color:rgb(25, 27, 31);">k^{(i)}</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">是网络中第 i 层的 kernel 大小，</font><font style="color:rgb(25, 27, 31);">c_{in}^{(i)}</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">是第 i 层的通道数。具有较小</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">l_p</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">范数的过滤器比具有较高</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">l_p</font><font style="color:rgb(25, 27, 31);">范数的过滤器更有可能被修剪。一些基于范数的剪枝方法（[69]）使用</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">l_1</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">norm 作为重要性指标。在这种情况下，这些方法也属于基于幅度的剪枝方法。此外，重要性值通常通过基于范数的稀疏正则化（[113]）进行优化，这将在 6.1 中讨论。</font>

### <font style="color:rgb(25, 27, 31);">敏感性和/或显著性</font>
<font style="color:rgb(25, 27, 31);">一些工作（[85,143,151]）利用敏感性和/或显著性来评估权重（或通道、过滤器等）的重要性。敏感性或显著性的定义在先前的工作中可能有所不同。例如，LeCun 等人[151]将权重显著性定义为通过修剪该权重引起的损失变化。</font>

<font style="color:rgb(25, 27, 31);">SNIP [46]提出了一种称为连接敏感度准则的显著性准则，作为导数 g 的归一化大小：</font>

<font style="color:rgb(25, 27, 31);">SNIP[46]提出了一个显著性准则，称为连接灵敏度准则，作为导数</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">g_{j}</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">的归一化幅度。</font>

`<font style="color:rgb(25, 27, 31);">s_{j}(\mathbf{w};\mathcal{D})=\frac{\left| g_{j}(\mathbf{w};\mathcal{D})\right|}{\sum_{k=1}^{m}\left| g_{k}(\mathbf{w};\mathcal{D})\right|} \\</font>`

<font style="color:rgb(25, 27, 31);">其中</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">s_j</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">是权重 j 的灵敏度，w 是网络权重，</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">g_{j}</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">是损失</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">L(\mathbf{w}\odot \mathbf{m})</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">关于</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">m_{j}</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">的导数。权重的敏感度越高，它就越重要。 VCP [85] 通过在被视为通道显著性的移位项</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">\beta</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">上扩展比例因子</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">\gamma</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">来重新构建 BN 层。他们将 BN 重新表述如下：</font>

`<font style="color:rgb(25, 27, 31);">\mathbf{x}_{out} = \gamma \cdot BN(\mathbf{x})+\tilde{\beta} \\</font>`

<font style="color:rgb(25, 27, 31);">其中，</font><font style="color:rgb(25, 27, 31);">\tilde{\beta}=\gamma \cdot \beta</font><font style="color:rgb(25, 27, 31);">。 VCP 不依赖</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">\gamma</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">的值，而是根据</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">\gamma</font><font style="color:rgb(25, 27, 31);">' 分布修剪不重要的通道。</font>

### <font style="color:rgb(25, 27, 31);">损失变化</font>
<font style="color:rgb(25, 27, 31);">通过评估有和没有权重（或滤波器、通道等）的网络损失变化来衡量权重的重要性是一种流行的标准。为了简单起见，我们以过滤器重要性评估为例。由于在逐个删除过滤器后重新评估整个网络的性能并非易事，因此一些研究人员（[13,50,71]）以基于泰勒展开的方式近似过滤器的重要性。</font>

<font style="color:rgb(25, 27, 31);">一阶泰勒展开式是最常见的用于测量loss变化的方法。 w 处微小扰动引起的loss变化定义如下：</font>

<font style="color:rgb(25, 27, 31);">\Delta \mathcal{L} = \mathcal{L}(\mathbf{w}+\Delta \mathbf{w}) - \mathcal{L}(\mathbf{w}) = \nabla_{\mathbf{w}} \mathcal{L}\ \Delta \mathbf{w}. \\</font>

<font style="color:rgb(25, 27, 31);">例如，GBN[13]将缩放因子</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">\boldsymbol{\lambda}</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">引入到 BN 中，并利用一阶泰勒展开来估计由于将某些缩放因子设置为零而引起的损失变化</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">\Delta \mathcal{L}</font><font style="color:rgb(25, 27, 31);">，如下所示：</font>

<font style="color:rgb(25, 27, 31);">\Delta \mathcal{L}(\boldsymbol{\lambda}) = \left | \boldsymbol{\lambda} \nabla_{\boldsymbol{\lambda}} \mathcal{L} - R_{1}(\boldsymbol{\lambda})\right | \approx \left | \boldsymbol{\lambda} \nabla_{\boldsymbol{\lambda}} \mathcal{L}\right |=\left| \frac{\partial \mathcal{L}}{\partial \boldsymbol{\lambda}} \boldsymbol{\lambda} \right|, \\</font>

<font style="color:rgb(25, 27, 31);">其中，</font><font style="color:rgb(25, 27, 31);">R_{1}(\boldsymbol{\lambda})</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">是拉格朗日余数。第 i 个过滤器的重要性得分定义为</font>

<font style="color:rgb(25, 27, 31);">\textrm{Score}(\mathcal{F}_i) = \mathop{\sum}\limits_{(\mathbf{x},\mathbf{y})\in \mathcal{D}}\left | \frac{\partial \mathcal{L}(\mathbf{y},f(\mathbf{x};\mathbf{w})}{\partial \lambda_i} \lambda_i\right | \\</font>

<font style="color:rgb(25, 27, 31);">其中，</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">\lambda_{i}</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">是第 i 个滤波器的标量因子。</font>

<font style="color:rgb(25, 27, 31);">损失函数的二阶泰勒展开式早在[151]中得到了应用，用于去除不重要的权重。并逐渐在许多后续方法中得到利用（[50, 71]），其中包括一阶（梯度）项、二阶（Hessian）项和高阶项被忽视。在不失一般性的情况下，近似的损失变化导致</font>

<font style="color:rgb(25, 27, 31);">\mathcal{L}(\mathbf{w}+\Delta \mathbf{w}) - \mathcal{L}(\mathbf{w}) = \nabla_{\mathbf{w}} \mathcal{L}\ \Delta \mathbf{w} + \frac{1}{2}\Delta \mathbf{w}^{T}H\Delta \mathbf{w}, \\</font>

<font style="color:rgb(25, 27, 31);">其中，</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">H=\nabla_{\mathbf{w}}^2 \mathcal{L}(\mathbf{w})</font><font style="color:rgb(25, 27, 31);">。</font>

<font style="color:rgb(25, 27, 31);">例如，GFP[71]应用二阶泰勒展开来近似移除通道时的loss变化（将其掩码设置为0）：</font>

<font style="color:rgb(25, 27, 31);">s_i = \Delta \mathcal{L} = \mathcal{L}(\mathbf{m}-\textbf{e}_\textbf{i}) - \mathcal{L}(\mathbf{m}) \approx -\textbf{e}_\textbf{i}^{T}\nabla_{\mathbf{m}} \mathcal{L}+\frac{1}{2}\textbf{e}_\textbf{i}^{T}(\nabla_{\mathbf{m}}^{2}\mathcal{L})\textbf{e}_\textbf{i} \\ = -\textbf{e}_\textbf{i}^{T}g + \frac{1}{2}\textbf{e}_\textbf{i}^{T}H\textbf{e}_\textbf{i}=-g_i+\frac{1}{2}H_{ii} \\</font>

<font style="color:rgb(25, 27, 31);">其中，</font><font style="color:rgb(25, 27, 31);">\textbf{e}_\textbf{i}</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">是第 i 个条目等于 1 的 one-hot 向量，</font><font style="color:rgb(25, 27, 31);">g</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">是损失函数</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">\mathcal{L}</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">关于</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">\mathbf{m}</font><font style="color:rgb(25, 27, 31);">的梯度。</font>

## <font style="color:rgb(25, 27, 31);">通过学习进行剪枝</font>
<font style="color:rgb(25, 27, 31);">在本节中，我们介绍一些通过学习来剪枝网络的方法，包括稀疏正则化（[62,64,124,152,153]）和一些基于元学习的剪枝方法（[87,152]），图神经网络（[154]）和强化学习（[43, 134]）。</font>

### <font style="color:rgb(25, 27, 31);">基于稀疏正则化的剪枝</font>
<font style="color:rgb(25, 27, 31);">基于稀疏正则化的剪枝通过解决以下问题来学习权重及其掩码：</font>

<font style="color:rgb(25, 27, 31);">\mathop{\textrm{min}}\limits_{\mathbf{w},\mathbf{m}} \mathcal{L}(\mathbf{w},\mathbf{m}) \\</font>

<font style="color:rgb(25, 27, 31);">其中</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">\mathcal{L}=\ell(\mathbf{w},\mathbf{m}) + \lambda \mathcal{R}(\cdot)</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">。此类剪枝方法的一种常见方式是为权重（或通道、滤波器等）引入缩放因子向量</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">\boldsymbol{\gamma}</font><font style="color:rgb(25, 27, 31);">。网络权重和缩放因子</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">\boldsymbol{\gamma}</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">与对后者施加的稀疏正则化联合训练。缩放因子的大小被视为重要分数。具体来说，</font><font style="color:rgb(25, 27, 31);">\mathcal{L}</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">如下所示：</font>

<font style="color:rgb(25, 27, 31);">\mathcal{L} = \frac{1}{N}\sum_{i=1}^{N}\ell(\mathbf{y}_i,f(\mathbf{x}_i;\mathbf{w}, \boldsymbol{\gamma}))+\lambda \sum_{\gamma_{i} \in \boldsymbol{\gamma}}\mathcal{R}(\gamma_{i}) \\</font>

<font style="color:rgb(25, 27, 31);">例如，He等人[124]将通道选择视为特征图的重建误差最小化，并将通道修剪问题表述如下：</font>

<font style="color:rgb(25, 27, 31);">\mathop{\textrm{min}}\limits_{\beta, \mathbf{w}} \frac{1}{2N}\lVert \mathbf{y} - \sum_{i=1}^{c} \beta_i X_i W_i^T\rVert_F^2 + \lambda \lVert \beta \rVert_1, \\</font><font style="color:rgb(25, 27, 31);">\textrm{subject to} \ \lVert \beta\rVert_0 \leq c', \forall i \ \lVert W_i \rVert_{F} = 1. \\</font>

<font style="color:rgb(25, 27, 31);">其中，</font><font style="color:rgb(25, 27, 31);">\lVert \cdot \rVert_{F}</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">是Frobenius范数，</font><font style="color:rgb(25, 27, 31);">X_i</font><font style="color:rgb(25, 27, 31);">是来自输入</font><font style="color:rgb(25, 27, 31);">\mathbf{x}</font><font style="color:rgb(25, 27, 31);">的第i个通道的</font><font style="color:rgb(25, 27, 31);">N \times k_{h}k_{w}</font><font style="color:rgb(25, 27, 31);">矩阵，</font><font style="color:rgb(25, 27, 31);">W_i</font><font style="color:rgb(25, 27, 31);">是来自</font><font style="color:rgb(25, 27, 31);">\mathbf{w}</font><font style="color:rgb(25, 27, 31);">的第i个通道的</font><font style="color:rgb(25, 27, 31);">n \times k_{h}k_{w}</font><font style="color:rgb(25, 27, 31);">权重，</font><font style="color:rgb(25, 27, 31);">k_h</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">和</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">k_w</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">分别是核的高度和宽度。</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">N</font><font style="color:rgb(25, 27, 31);">,</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">c</font><font style="color:rgb(25, 27, 31);">,</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">c'</font><font style="color:rgb(25, 27, 31);">, 和</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">n</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">分别是样本数、通道数、保留通道数和滤波器数。为了解决这个问题，He 等人[124]使用LASSO回归[127]和贪婪策略来选择不重要的通道。</font>

### <font style="color:rgb(25, 27, 31);">基于元学习的剪枝</font>
<font style="color:rgb(25, 27, 31);">一些工作（[87, 152]）采用元学习来剪枝模型。例如，MetaPruning [87] 训练元网络 PruningNet 来预测不同剪枝网络的权重。 PruningNet 将网络编码向量</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">(v_1, v_2, ..., v_L)</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">作为输入并输出剪枝网络的权重</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">\mathbf{w}</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">：</font>

<font style="color:rgb(25, 27, 31);">\mathbf{w} = \textrm{PruningNet}(v_1,v_2,...,v_L) \\</font>

<font style="color:rgb(25, 27, 31);">其中，</font><font style="color:rgb(25, 27, 31);">v_i</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">是第 i 层的通道数。通过将网络编码输入到充分训练的 PruningNet 中，获得每个剪枝网络的权重和相应的准确率。考虑到网络编码向量的巨大搜索空间，在约束条件下通过进化搜索找到剪枝网络。</font>

### <font style="color:rgb(25, 27, 31);">基于图神经网络的剪枝</font>
<font style="color:rgb(25, 27, 31);">任何网络都可以被视为图。 GraphPruning[154]首次将图卷积应用于模型压缩。具体来说，GraphPruning 设计了一个权重为</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">\mathbf{\theta}_{G}</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">的图聚合器</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">G</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">，与全连接（FC）层相结合，生成剪枝网络的权重</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">\mathbf{w} = (\mathbf{w}^{(1)},\mathbf{w}^{(2)},...,\mathbf{w}^{(L)})</font><font style="color:rgb(25, 27, 31);">，如下所示：</font>

<font style="color:rgb(25, 27, 31);">(n_1,n_2,...,n_{L}) = G(b_1,b_2,...,b_{L}|\mathbf{\theta}_{G}), \\ \mathbf{w}^{(i)} = FC_{i}(n_{i}|\mathbf{\theta}_{i}), \\</font>

<font style="color:rgb(25, 27, 31);">其中，</font><font style="color:rgb(25, 27, 31);">b_{i}\in R^{1\times 7}</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">表示第i个节点的嵌入特征，</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">n_i</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">是图聚合器输出的第i列，</font><font style="color:rgb(25, 27, 31);">\theta_{i}</font><font style="color:rgb(25, 27, 31);">是第i个FC层的权重，</font><font style="color:rgb(25, 27, 31);">\mathbf{w}^{(i)}</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">是剪枝网络的第i个剪枝层的权重。然后，剪枝后的网络在数据集上进行全面训练。这里，图聚合器负责提取每个节点的高级特征，而每个FC层用于为剪枝后的网络生成合理的权重。然后，通过强化学习方法搜索计算约束下剪枝网络的最佳配置，在此期间图聚合器和 FC 的权重不更新。</font>

### <font style="color:rgb(25, 27, 31);">基于强化学习的剪枝</font>
<font style="color:rgb(25, 27, 31);">一些 AutoML 剪枝方法 ([43, 134]) 采用 RL 自动压缩模型，而不是使用 [154] 中的 RL 来搜索剪枝网络的最佳配置。例如，He等人[43]提出了基于 Q-learning（RL的一种）的 AutoML 模型压缩（AMC）方法，以关注代理应如何采取行动以最大化累积奖励。具体来说，He 等人[43]设计了深度确定性策略梯度（DDPG）代理来从环境中接收层</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">l_{i}</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">的嵌入状态</font><font style="color:rgb(25, 27, 31);">s_{i}</font><font style="color:rgb(25, 27, 31);">，并输出稀疏比率作为动作</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">a_{i}</font><font style="color:rgb(25, 27, 31);">。然后使用特定的压缩方法（例如：通道剪枝方法）对层进行压缩。之后，智能体移动到第</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">l_{i+1}</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">层，执行与第</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">l_{i}</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">层相同的工作，直到最后第</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">l_{L}</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">层。更新流程如下：</font>

<font style="color:rgb(25, 27, 31);">Loss = \frac{1}{N}\sum_{i=1}^{N}(y_{i}-Q(s_{i},a_{i}|\mathbf{w}^{Q}))^{2}, \\ y_{i} = r_{i}-b+\gamma Q(s_{i+1},\mu \ (s_{i+1})|\mathbf{w}^{Q}), \\</font>

<font style="color:rgb(25, 27, 31);">其中，</font><font style="color:rgb(25, 27, 31);">b</font><font style="color:rgb(25, 27, 31);">是基线奖励，</font><font style="color:rgb(25, 27, 31);">\gamma</font><font style="color:rgb(25, 27, 31);">是一个折扣因子，用于避免过度优先考虑短期奖励，</font><font style="color:rgb(25, 27, 31);">\mathbf{w}^{Q}</font><font style="color:rgb(25, 27, 31);">是遵循Block-QNN[155]的网络</font><font style="color:rgb(25, 27, 31);">Q</font><font style="color:rgb(25, 27, 31);">的权重，</font><font style="color:rgb(25, 27, 31);">r_{i}</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">是第</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">i</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">个样本的整个轨迹的奖励。</font>

<font style="color:rgb(25, 27, 31);">He等人[43]观察到</font><font style="color:rgb(25, 27, 31);">\textrm{Error}</font><font style="color:rgb(25, 27, 31);">与</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">log(\textrm{FLOPs})</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">或</font><font style="color:rgb(25, 27, 31);"> </font><font style="color:rgb(25, 27, 31);">log(\#\textrm{Param})</font><font style="color:rgb(25, 27, 31);">成反比。基于这一观察，奖励函数定义为：</font>

<font style="color:rgb(25, 27, 31);">\textrm{R}_{\textrm{FLOPs}} = -\textrm{Error} \cdot log(\textrm{FLOPs}), \\ \textrm{R}_{\textrm{Param}} = -\textrm{Error} \cdot log(\# \textrm{Param}). \\ \\</font>

<font style="color:rgb(25, 27, 31);">该奖励函数提供了减少 FLOP 或网络参数数量的激励。</font>

## <font style="color:rgb(25, 27, 31);">综合比较分析</font>
<font style="color:rgb(25, 27, 31);">在本节中，我们重点对不同剪枝方式的表现进行比较分析，包括七对剪枝的对比设置、网络的不同层密度以及剪枝的不同监督级别。我们还进行了比较实验，以检查不同对比度设置下 CIFAR-10[156]/CIFAR-100[156] 上 VGGNet [2]/ResNet[6] 的一些剪枝方法。实验设置参见附录A。</font>

![](https://cdn.nlark.com/yuque/0/2025/png/2639475/1740118467112-8ebc4403-bb2f-43b8-8646-1d3e88ce8643.png)

<font style="color:rgb(145, 150, 161);">image.png</font>

<font style="color:rgb(25, 27, 31);">表6：非结构化和结构化剪枝的优点和缺点。</font>

![](https://cdn.nlark.com/yuque/0/2025/png/2639475/1740118467062-22763545-b132-45d3-b920-79e51b4b38e2.png)

<font style="color:rgb(145, 150, 161);">image.png</font>

<font style="color:rgb(25, 27, 31);">表 7：VGG-16 的非结构化和结构化剪枝的 Top-1 准确度，最佳结果以粗体显示。</font>

### <font style="color:rgb(25, 27, 31);">非结构化与结构化剪枝</font>
<font style="color:rgb(25, 27, 31);">非结构化剪枝方法 ([11, 70]) 可以消除任何位置的权重，并且可以实现高剪枝率，而对精度影响很小。相比之下，结构化剪枝（[13,50,71]）在整个过滤器（或通道、神经元、块、层等）上进行剪枝，这会导致真正压缩网络并加速推理，但与相同剪枝比率、权重级别评分、流水线和学习方案下的非结构化剪枝相比，精度很可能较低。</font>

<font style="color:rgb(25, 27, 31);">可能的原因是非结构化剪枝只关注单个权重的重要性，而结构化剪枝则强调结构耦合，这需要同时剪枝多层，并期望所有移除的权重始终不重要。然而，在结构耦合约束下满足不重要权重的一致性具有挑战性。表 6 简要总结了非结构化和结构化剪枝的优缺点。我们在 3 次随机运行中对 CIFAR-10 [156] 上的 VGG-16 进行了剪枝，并报告了比较 SNIP [46] 和 GraSP 的非结构化和结构化剪枝的最佳结果[61]。普通 SNIP 和 GraSP 是非结构化剪枝，分别由表 7 中的 SNIP-unstruct 和 GraSP-unstruct 表示。为了剪枝通道，在通过普通 SNIP 或 GraSP 对每个权重进行评分后，计算每个通道中的权重级别分数的总和作为其重要性分数。如表7所示，对于SNIP和GraSP，在相同的权重剪枝比下，非结构化剪枝的Top-1精度通常优于其相应的结构化剪枝。</font>

### <font style="color:rgb(25, 27, 31);">一次性剪枝与迭代剪枝</font>
<font style="color:rgb(25, 27, 31);">一次性剪枝方法得分一次，然后将网络剪枝到目标剪枝率。相反，迭代剪枝方法交替处理得分-剪枝-再训练的循环，直到达到目标剪枝率。因此，一次性剪枝方法的成本通常可以忽略不计，这大大节省了剪枝工作。然而，这种方法对于那些一开始重要性并不明显的重要权重并不友好[109]。因此，一次性剪枝通常需要更仔细设计的评分标准以匹配原始网络的性能。此外，[39]的结果表明，一次性剪枝可能更容易遭受层崩溃，导致精度急剧下降。相反，迭代方法需要更多的剪枝成本，但通常会产生更好的精度[13,69,110,120,157]。</font>

<font style="color:rgb(25, 27, 31);">林等人[97]从随机梯度的角度分析了一次性剪枝方法和迭代剪枝方法的区别。他们的结果表明，迭代剪枝方法在剪枝模型上计算随机梯度，并采取最适合压缩模型的步骤。相比之下，一次性剪枝方法在原始权重上计算随机梯度，并向最佳密集模型移动。</font>

<font style="color:rgb(25, 27, 31);">我们分别在一次性剪枝或迭代剪枝下通过 SynFlow [39] 和基于幅度的剪枝（为简单起见，下文中将其称为幅度）对 CIFAR-10 上的 VGG-16 和 ResNet-32 进行剪枝。如图7所示，迭代剪枝的Top-1精度通常优于相应的一次性剪枝。</font>

![](https://cdn.nlark.com/yuque/0/2025/png/2639475/1740118468542-416009eb-cb1f-4561-bd8b-3b6a29b32d76.png)

<font style="color:rgb(145, 150, 161);">image.png</font>

<font style="color:rgb(25, 27, 31);">图 7：CIFAR-10 上的一次性剪枝与迭代剪枝。阴影区域表示基于三个独立运行的标准偏差（最佳颜色视图）。</font>

### <font style="color:rgb(25, 27, 31);">无数据与数据驱动的剪枝</font>
<font style="color:rgb(25, 27, 31);">大多数现有的剪枝工作（[46,50,71]）属于数据驱动的方法，只有少数方法（[39,60,158,159]）是无数据的。人们普遍认为数据对于寻找良好的子网络至关重要。</font>

<font style="color:rgb(25, 27, 31);">我们通过两种无数据剪枝方法（即 SynFlow [39] 和 Smart-Ratio [60]）和两种数据驱动方法（即 SNIP [46] 和 Magnitude）在 CIFAR-10 和 SVHN 上修剪 VGG-16。 CIFAR-10 和 SVHN 都是10个分类数据集。如图8所示，CIFAR-10上SynFlow 或 Smart-Ratio 对VGG-16每层的剪枝率与 SVHN 上相应层的剪枝率相同。然而，当 SNIP 或 Magnitude 在 CIFAR-10 和 SVHN 上修剪 VGG16 时，每层的修剪比率有所不同。特别是对于 Magnitude，CIFAR-10 上较低层的剪枝率与 SVHN 上的剪枝率不同。</font>

<font style="color:rgb(25, 27, 31);">表8中的结果是三轮随机运行中的最佳结果，并且表明，尽管无数据方法在CIFAR-10[156]、SVHN和CIFAR-100[156]中，在50%或90%的参数被修剪后，获得了很好的Top-1精度，但数据驱动的方法在大多数情况下表现更好。</font>

<font style="color:rgb(25, 27, 31);">在这些方法中，SNIP 表现最好。虽然它只使用少量随机选择的样本（即每类一个样本）来计算权重分数，但数据对于 SNIP 至关重要。当它获得随机输入时，如 SNIP（无数据）所示，其 Top-1 准确度通常会下降。</font>

![](https://cdn.nlark.com/yuque/0/2025/png/2639475/1740118468513-1e457995-7599-4f51-a24c-99bc62e454a5.png)

<font style="color:rgb(145, 150, 161);">image.png</font>

<font style="color:rgb(25, 27, 31);">图 8：通过在 CIFAR-10 和 SVHN 上进行无数据和数据驱动剪枝，具有 90% 权重剪枝比的 VGG-16 架构的图示。</font>

![](https://cdn.nlark.com/yuque/0/2025/png/2639475/1740118469148-118eb1a5-b907-403f-b28b-2decd8ec0482.png)

<font style="color:rgb(145, 150, 161);">image.png</font>

<font style="color:rgb(25, 27, 31);">表 8：VGG-16的无数据和数据驱动的剪枝方法的Top-1准确率（%）。 CIFAR-10、SVHN 和 CIFAR-100 上的原始 Top-1 准确率分别为 93.76%、96.36% 和 73.22%。最佳结果以粗体显示。</font>

### <font style="color:rgb(25, 27, 31);">初始化权重与预训练权重的剪枝</font>
<font style="color:rgb(25, 27, 31);">Frankle等人[48]发现，通过对随机初始化权值(如SNIP[46]、GraSP[61]、SynFlow[39])进行剪枝得到的子网对消融处理(即在保持掩码不变的情况下随机洗牌每层内的掩码位置或重新初始化权值)具有鲁棒性。</font>

<font style="color:rgb(25, 27, 31);">为了找到这种免疫背后的原因，Singh和Liu[160]使用Wasserstein距离来衡量分布相似性，发现这些消融对剩余权重分布的改变最小，这加强了保持相似的性能。</font>

<font style="color:rgb(25, 27, 31);">相比之下，苏等人[60]发现通过修剪预训练权重实现的子网络（例如：LTH[47]）对这些消融很敏感。 Qiu和Suda[161]声称训练权重可以解耦为两个维度：权重的位置及其精确值，其中权重的位置保存了训练编码的大部分信息。沃尔夫等人[162]从理论上分析了预训练对剪枝子网络性能的影响。尽管预训练对于 PAT 方法至关重要，但它并不总是能带来好处。我们进行了一些实验来探索预训练权重是否有助于 PBT 方法找到更好的子网络。图 9 中的结果表明，对于 SynFlow [39] 和 SNIP [46]，对预训练权重的剪枝并不能保证提高 Top-1 精度。对于某些权重剪枝比例，结果更糟。</font>

![](https://cdn.nlark.com/yuque/0/2025/png/2639475/1740118468829-853a27e9-e070-48fb-aea6-fe5898979b8f.png)

<font style="color:rgb(145, 150, 161);">image.png</font>

<font style="color:rgb(25, 27, 31);">图 9 ：CIFAR-10上初始化和预训练的权重。阴影区域表示基于三次独立运行的标准偏差(以颜色显示最佳视图)。</font>

### <font style="color:rgb(25, 27, 31);">从头开始训练与微调</font>
<font style="color:rgb(25, 27, 31);">剪枝后，许多剪枝方法需要对子网络进行几个epoch的训练才能恢复性能。 Le 和 Hua[163]认为，再训练对于恢复剪枝中的损失准确性至关重要。一般来说，再训练可以分为两种：从头开始训练或微调。关于微调是否比从头开始训练更能恢复准确性一直存在争议。一方面，刘等人[38]发现对于ResNet、VGG和ImageNet上的其他标准结构，使用新的随机初始化来训练子网络可以获得比微调它们更好的性能。另一方面，Li等人[69]观察到，从头开始训练一个子网络的效果不如对其进行微调。</font>

<font style="color:rgb(25, 27, 31);">刘等人[120] 使用基于 ADMM [164]的一次性剪枝方法研究了 CIFAR-10 上的 ResNet20 剪枝，发现剪枝和微调在各种剪枝比率上优于 LTH（从头开始剪枝和训练）。此外，[129, 165]中的结果表明，为了在稀疏移动网络上获得比从头开始训练更好的性能，微调是必要的。</font>

<font style="color:rgb(25, 27, 31);">近年来，一些折衷方法（例如：权重倒带[53]）被提出。 [40, 53]中的结果表明，权重倒带可以比微调获得更高的精度。我们通过 Magnitude 和 SNIP [46] 在 CIFAR-32 上剪枝 ResNet-32，然后从头开始训练修剪后的网络或对其进行微调。图 10 中的结果表明，对于 Magnitude 和 SNIP，微调的效果优于从头开始的训练。</font>

![](https://cdn.nlark.com/yuque/0/2025/png/2639475/1740118468646-907110d3-f73c-42c7-8f96-71a20dad0d9e.png)

<font style="color:rgb(145, 150, 161);">image.png</font>

<font style="color:rgb(25, 27, 31);">图10：基于ResNet-32从头开始训练与微调。阴影区域表示基于三次独立运行的标准偏差(以颜色显示最佳视图)。</font>

### <font style="color:rgb(25, 27, 31);"> 原始任务与迁移修剪</font>
<font style="color:rgb(25, 27, 31);">在最近的文献中，剪枝与迁移学习[166]相结合，可以显著提高准确性并加速收敛。为了便于区分，在本次调查中，使用原始任务剪枝来表示直接执行目标任务的整个剪枝流程。相反，传输剪枝在源任务上执行，然后将子网络传输到目标任务。具体来说，传输剪枝分为两种类型：数据集传输和架构传输。前者在源数据集上修剪网络并将子网络转移到目标数据集，后者在一种架构上剪枝并将子网转移到另一种架构。</font>

<font style="color:rgb(25, 27, 31);">一些工作（[110,123,167,168]）研究了稀疏掩模跨数据集的可迁移性。例如，Tiwari等人[123]将 CIFAR-100 上剪枝网络的 Top-1 精度与在 Tiny ImageNet 上学习掩模并迁移到 CIFAR-100 的网络进行比较。结果表明，迁移的掩模比直接从原始任务获得的掩模表现更好，删除了 40% 的通道。 S. Morcos等人[109]观察到，对于图像分类，在较大数据集（例如：更大的训练集大小和/或更多类别数量）上生成的中奖彩票始终比在较小数据集上生成的中奖彩票迁移更好。例如，在 ImageNet 和 Places365 上生成的中奖彩票比在 CIFAR-10 和 CIFAR-100 等其他较小的目标数据集上表现出更好的性能。</font>

<font style="color:rgb(25, 27, 31);">Iofinova等人[169] 提出了对子网络迁移性能进行了开创性的研究，并发现在 ImageNet [1] 上具有相似 Top-1 精度的剪枝方法在用于迁移学习时可能具有惊人的不同Top-1精度。对于架构转移剪枝，Elastic Ticket Transformations(ETT) [42] 将一种网络（ResNet [6] 或 VGG [2]）中找到的中奖票转换为来自同一模型系列的另一种更深或更浅的网络。</font>

### <font style="color:rgb(25, 27, 31);">静态剪枝与动态剪枝</font>
<font style="color:rgb(25, 27, 31);">静态剪枝[12]使用静态剪枝标准并永久删除组件。相比之下，动态剪枝（[51,135,136,170]）利用特定于输入的特征剪枝标准，保留整个网络结构，并通过动态跳过不重要的组件来加速网络。然而，动态剪枝通常不执行运行时微调或重新训练。静态剪枝和动态剪枝的区别主要体现在剪枝标准和剪枝模型上。静态剪枝和动态剪枝的优缺点如表9所示。</font>

![](https://cdn.nlark.com/yuque/0/2025/png/2639475/1740118469134-f71592fb-6717-45eb-9505-1524ffaa6de1.png)

<font style="color:rgb(145, 150, 161);">image.png</font>

### <font style="color:rgb(25, 27, 31);"> 逐层权重密度分析</font>
<font style="color:rgb(25, 27, 31);">一些工作（[71,119,154,171]）研究了子网络逐层权重密度的分布，其结果表明不同层可以具有非常不同的权重密度。这种差异是由稠密网络的结构特征和剪枝方法共同作用产生的。</font>

<font style="color:rgb(25, 27, 31);">Zhang 等人[172]根据经验研究了层的异质性特征，并将层分为 "环境层 "和 "关键层"。环境层对改变权重的初始值不敏感，而关键层则敏感。由此看来，环境层应该被大量修剪，相应的权重密度也会更低。</font>

<font style="color:rgb(25, 27, 31);">剪枝方法也会导致不同的权重密度。以图像分类的剪枝为例。一些修剪方法倾向于为较早的层分配比后面的层更多的权重。例如，Ma 等人[119]研究了GraSP、SNIP[46]、LTH在VGG和ResNet上获得的子网络的逐层保持率，并观察到除了一些特殊层（例如：如 ResNet 中的下采样层）。相比之下，刘等人[71]发现他们的剪枝网络在图像分类中比较低层中的通道保留了更高百分比的通道。 [171]中的结果表明，全局幅度剪枝倾向于均匀地剪枝 Transformer 的层[173]，而全局一阶方法会大量剪枝更深的层。</font>

### <font style="color:rgb(25, 27, 31);">不同监督级别的剪枝</font>
<font style="color:rgb(25, 27, 31);">按照神经网络剪枝过程中监督级别的降序，剪枝可以分为监督剪枝、半监督剪枝、自监督剪枝和无监督剪枝[174]。</font>

<font style="color:rgb(25, 27, 31);">自监督学习可以分为两类：生成学习或对比学习[175]。与监督学习一样，监督剪枝适用于完全标记的数据集。目前大多数的剪枝方法都属于监督剪枝。然而，监督剪枝也面临着与监督学习类似的瓶颈（例如：昂贵的手动标记）。作为一种有前途的替代方案，半监督、自监督和无监督剪枝引起了广泛的关注。</font>

<font style="color:rgb(25, 27, 31);">例如，Caron等人[176]观察自监督剪枝与监督剪枝的不同结果，其中中奖彩票初始化与随机重新初始化相比仅带来了轻微的性能改进。潘等人[177]声称无监督剪枝通常无法保持原始模型的准确性。值得注意的是，网络修剪和训练的标签监督可以是独立的。例如，陈等人[168]使用监督剪枝方法IMP（即迭代幅度剪枝）来探索ImageNet上自监督预训练模型（simCLR [178] 和 MoCo [179]）的子网络。同样，Jeff Lai 等人[180]利用监督剪枝方法 IMP 来剪枝自监督语音识别模型。</font>

## <font style="color:rgb(25, 27, 31);">剪枝和其他压缩技术的融合</font>
<font style="color:rgb(25, 27, 31);">在本节中，我们回顾了神经网络剪枝与其他网络压缩技术的融合，如量化[11]、张量分解[144]、知识蒸馏[21]和网络架构搜索[73]。然而，一方面，融合为网络压缩提供了更多选择。另一方面，组合的压缩技术可以相互补充，进一步提高性能和剪枝率。</font>

    - <font style="color:rgb(25, 27, 31);">剪枝和量化：量化[147]是一种压缩技术，用于减少用于表示网络权重和/或激活的位数，这可以显着减少模型大小和内存占用，但性能会略有下降。为了获得更紧凑的模型以及模型加速，Han 等人[11]率先修剪冗余网络连接并量化权重。 CLIP-Q [147]在微调阶段联合执行剪枝和量化。 MPT [108] 集成了修剪和量化随机加权全精度神经网络以获得二进制权重和/或激活。 EB[130]将8位低精度训练应用于EB票搜索阶段。</font>
+ <font style="color:rgb(25, 27, 31);">剪枝和张量分解：张量分解[19]将卷积分解为参数较少的张量序列。与剪枝相反，它探索原始权重的低秩结构，保持卷积输出的维度不变。 CC[144]结合通道剪枝和张量分解，通过同时学习模型稀疏性和低秩来压缩CNN模型。 Hinge [181] 在相同的公式下引入了群稀疏性来融合滤波器剪枝和分解。</font>
+ <font style="color:rgb(25, 27, 31);">剪枝&NAS：神经架构搜索（NAS）提供了一种自动发现感兴趣问题的最佳架构的机制，这为剪枝找到合适的网络深度和宽度提供了新的思路。 NPAS [73] 执行编译器感知的联合网络修剪和架构搜索，确定过滤器类型（不同的核大小）、修剪方案和每层的速率。 TAS [182]利用NAS来搜索网络的深度和宽度以获得剪枝网络，并使用知识蒸馏来训练这些剪枝网络。</font>
+ <font style="color:rgb(25, 27, 31);">剪枝和知识蒸馏：知识蒸馏（KD）[21]引导学生有效地继承老师的知识并模仿老师的输出。一些工作（[183, 184]）利用 KD 之前的剪枝来提高 KD 质量。例如，刘等人[183]剪枝感兴趣内容的不重要通道，并将蒸馏集中在感兴趣的区域。 Park 和 No [184] 首先修剪教师网络，使其更易于转移，然后将其提炼给学生。一些工作（[66,135,185]）使用 KD 来训练剪枝网络。 [185]中的结果表明，通过 KD 恢复的剪枝网络比通过微调恢复的表现更好。邹等人[186]提出了一种无数据导出模型压缩方法，该方法提取剪枝模型以适应预训练模型。</font>
+ <font style="color:rgb(25, 27, 31);">修剪和多重压缩技术：一些工作 ([187, 188]) 探索了剪枝与多种压缩技术的融合。例如，GS [189]融合了剪枝、量化和 KD，用于生成对抗网络（GAN）压缩。 Joint-DetNAS [188] 联合剪枝、NAS 和 KD 进行图像翻译。 LadaBERT [187] 集成了剪枝、矩阵分解和 KD 来压缩来自 Transformers (BERT) [132] 的双向编码器表示，以实现自然语言理解。</font>

## <font style="color:rgb(25, 27, 31);">建议和未来方向</font>
<font style="color:rgb(25, 27, 31);">在本节中，我们讨论如何选择不同的修剪方法，并为未来的工作提供有希望的方向。</font>

### <font style="color:rgb(25, 27, 31);">修剪方法选择的建议</font>
<font style="color:rgb(25, 27, 31);">经过多年的研究和探索，现成的剪枝方法有很多。然而，没有黄金标准来衡量哪一个是最好的。存在不同的剪枝方法来压缩深度神经网络以满足特定的应用要求以及硬件和软件资源。以下是选择适当剪枝方法的一些一般建议。</font>

+ <font style="color:rgb(25, 27, 31);">如果你没有特殊的硬件（例如：FPGA 或 ASIC）或软件（例如：稀疏卷积库），但需要实际的神经网络加速和压缩，结构化剪枝比非结构化剪枝更合适，因为大多数软件框架和硬件都无法做到加速稀疏矩阵的计算。</font>
+ <font style="color:rgb(25, 27, 31);">如果在剪枝阶段有足够的计算资源，可以考虑迭代PAT方法。总体而言，此类方法可以在相同剪枝率下将对性能的影响降到最低。另一方面，如果在剪枝和推理阶段的计算资源有限，则可以考虑一次性训练前剪枝或一次性训练后剪枝方法。</font>
+ <font style="color:rgb(25, 27, 31);">如果目标任务上有足够的标注示例，可以考虑监督剪枝方法。如果目标任务上仅标注了几个示例，则可以考虑半监督或迁移剪枝方法。如果目标任务上的示例没有标注，则可以考虑自监督、无监督或迁移剪枝方法。</font>
+ <font style="color:rgb(25, 27, 31);">如果在 NLP 任务的剪枝期间需要足够的内存占用，可以考虑对大模型进行大量压缩，而不是在满足相同预算的情况下轻微压缩较小的模型。 [190] 中的一些结果表明，对于 NLP 任务，从大型密集网络中找到修剪模型优于模型大小与剪枝模型相当的小型密集网络。</font>
+ <font style="color:rgb(25, 27, 31);">如果你有足够的内存占用来存储推理阶段的密集神经网络，并希望为不同的输入提供运行时灵活的计算成本分配，可以考虑动态剪枝方法，其中形状较小的输入可以分配较少的计算成本执行任务，如果输入形状更大，则可以分配更多的计算成本。</font>
+ <font style="color:rgb(25, 27, 31);">如果需要多维度对神经网络进行剪枝，可以综合考虑分层剪枝（减小模型深度）、通道剪枝（减小模型宽度）和图像分辨率剪枝（缩小模型输入分辨率）。此外，剪枝可以与量化相结合，以进一步减少内存占用和神经网络的大小。</font>
+ <font style="color:rgb(25, 27, 31);">如果你想在速度和精度之间达到更好的权衡，以下设置可能会有所帮助：使用预训练模型；在剪枝和再训练阶段设置更合适的学习率（如果有）；用几个epoch微调剪枝模型；整合剪枝、知识蒸馏、NAS或其他压缩方法实现互补；对抗性训练可能也有一些帮助[111]。</font>
+ <font style="color:rgb(25, 27, 31);">如果需要训练一个子网络来恢复损失精度，[119]中的结果表明，当存在残留连接时，子网络以相对较小的学习率获得更高的精度。相反，在训练无残留连接的子网络时，较大的学习率是优选的。</font>

### <font style="color:rgb(25, 27, 31);">未来的发展方向</font>
<font style="color:rgb(25, 27, 31);">神经网络剪枝进一步发展的四个有希望的方向，理论、技术、应用和评估。</font>

+ <font style="color:rgb(25, 27, 31);">理论：尽管有现有的工作，但仍然需要回答有关剪枝的几个基本问题。例如，先前的工作表明网络层包含不可替代的信息以及冗余信息。对于给定的网络，是否存在剪枝比的理论上限，该上限仍然保持其密集等效网络的匹配性能？换句话说，理论上可以在不损失精度的情况下对网络进行多大程度的修剪？由于网络层之间的关系错综复杂，这是一个棘手的问题。此外，剪枝可以解释吗？人们普遍认为深度神经网络很难解释。因此，进行可解释的剪枝是一项艰巨的任务。然而，剪枝的可解释性对于理解剪枝背后的因素（例如：模型结构和权重）和探索更有效的剪枝方法至关重要。</font>
+ <font style="color:rgb(25, 27, 31);">技术：为了获得更好的算法设计，其架构可以以经济、高效、有效的方式学习，将自动机器学习（AutoML）方法和NAS扩展到剪枝是一种趋势。此外，剪枝也开始与各种学习环境相结合，如终身学习[66]、持续学习[191]、对比学习[32]、联邦学习[192]等。此外，网络不断上升的能耗需要更多注意能耗感知剪枝。然而，初步的努力主要集中在减少计算和内存成本，这不一定能减少最多的能耗。此外，将剪枝融入硬件中以帮助部署剪枝网络也是一种新兴趋势。例如，隋等人[54]提出了一种硬件友好的剪枝方法，并将剪枝后的模型部署在FPGA平台上。</font>
+ <font style="color:rgb(25, 27, 31);">应用：之前的主流研究主要针对CV领域的剪枝研究，尤其是图像分类领域。最近，剪枝开始引起人们对更复杂应用的关注，如对象跟踪、视觉问答、自然语言理解、语音识别等。例如，近年来，GPT-4 [193] 等基础模型可能是通用人工智能（AGI）的可能途径。然而，其庞大的模型阻碍了其在许多下游任务中的应用。因此，巨大的基础模型可以受益于剪枝研究，变得更加紧凑和高效[15]。</font>
+ <font style="color:rgb(25, 27, 31);">评估：随着许多剪枝方法的出现，需要标准化的基准和指标来提供公平的评估。不同的剪枝技术、网络架构、任务和实验设置会导致无法比较的结果，并且很难公平地比较剪枝方法[194]。ShrinkBench [37] 迈出了第一步，为图像分类提供了剪枝方法的基准。由于剪枝需应用于图像分类以外的应用，因此需要对其他应用进行的标准化基准和指标。</font>

## <font style="color:rgb(25, 27, 31);">结论</font>
<font style="color:rgb(25, 27, 31);">作为一种重要的压缩技术，深度神经网络剪枝随着最近出现的各种剪枝方法和应用而引起了越来越多的研究关注。本次调查对以下四个范围进行了全面回顾：</font>

1. <font style="color:rgb(25, 27, 31);">通用/特定加速，从非结构化、结构化和半结构化剪枝进行系统回顾；</font>
2. <font style="color:rgb(25, 27, 31);">何时剪枝，包括静态剪枝（训练之前/期间/之后的剪枝）和运行时剪枝；</font>
3. <font style="color:rgb(25, 27, 31);">如何剪枝，包括通过启发式标准和通过学习进行剪枝；</font>
4. <font style="color:rgb(25, 27, 31);">剪枝与其他压缩技术的融合，如KD、NAS等。</font>

<font style="color:rgb(25, 27, 31);">全面的比较分析，包括七对剪枝的对比设置、逐层权重密度和不同的监督级别，可以帮助研究人员高效、有效地掌握不同剪枝方法的特点。此外，还重点讨论了修剪方法的选择和未来研究方向的建议。</font>

<font style="color:rgb(25, 27, 31);">为了方便未来的研究，附录B总结了现实世界的各种应用以及不同应用中常用的数据集、网络和评估指标资源。为了帮助研究人员和实践者跟上剪枝技术的发展，我们不断更新代表有关剪枝的研究工作和开源代码，具体请参考：</font>[https://github.com/hrcheng1066/awesome-pruning](https://github.com/hrcheng1066/awesome-pruning)



  
 

