# <font style="color:rgb(0, 0, 0);">Python 特殊语法详解</font>
## <font style="color:rgb(0, 0, 0);">列表推导式 (List Comprehension)</font>
<font style="color:#DF2A3F;">好怪的语法</font>

```python
# 生成平方数列表
squares = [x**2 for x in range(5)]  # [0, 1, 4, 9, 16]

# 带条件过滤
even_squares = [x**2 for x in range(10) if x % 2 == 0]  # [0,4,16,36,64]
```

Go 对比实现：

```go
// Go 需手动循环
var squares []int
for x := 0; x < 5; x++ {
    squares = append(squares, x*x)
}
```

## <font style="color:rgb(0, 0, 0);">字典推导式 (Dict Comprehension)</font>
```python
# 创建字符映射
word = "hello"
char_map = {char: index for index, char in enumerate(word)}
# {'h':0, 'e':1, 'l':2, 'o':4}
```

Go 对比实现

```go
// Go 需显式初始化
word := "hello"
charMap := make(map[rune]int)
for i, c := range word {
    charMap[c] = i
}
```

## <font style="color:rgb(0, 0, 0);">装饰器 (Decorator)</font>
```python
def logger(func):
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@logger
def add(a, b):
    return a + b

add(2, 3)  # 输出: Calling add → 返回5
```

Go 对比实现（需手动包装）

```go
// Go 无原生装饰器，通过函数组合实现
func Logger(f func(int, int) int) func(int, int) int {
    return func(a, b int) int {
        fmt.Println("Calling function")
        return f(a, b)
    }
}

add := Logger(func(a, b int) int { return a + b })
add(2, 3)
```

## <font style="color:rgb(0, 0, 0);">上下文管理器 (Context Manager)</font>
```python
# 自定义上下文管理器
class FileHandler:
    def __init__(self, filename):
        self.filename = filename

    def __enter__(self):
        self.file = open(self.filename, 'r')
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.file.close()

with FileHandler("data.txt") as f:
    content = f.read()
```

 Go 对比实现（defer + 结构体方法）

```go
type FileHandler struct {
    file *os.File
}

func OpenFile(name string) (*FileHandler, error) {
    f, err := os.Open(name)
    return &FileHandler{file: f}, err
}

func (fh *FileHandler) Close() {
    fh.file.Close()
}

func main() {
    fh, _ := OpenFile("data.txt")
    defer fh.Close()
    content, _ := io.ReadAll(fh.file)
}
```

## <font style="color:rgb(0, 0, 0);">生成器 (Generator)</font>
```python
# 生成斐波那契数列
def fibonacci(limit):
    a, b = 0, 1
    while a < limit:
        yield a
        a, b = b, a + b

for num in fibonacci(100):
    print(num)  # 0,1,1,2,3,5,8,13,21,34,55,89
```

Go 对比实现（通过通道）

```go
func Fibonacci(limit int) <-chan int {
    ch := make(chan int)
    go func() {
        a, b := 0, 1
        for a < limit {
            ch <- a
            a, b = b, a+b
        }
        close(ch)
    }()
    return ch
}

func main() {
    for num := range Fibonacci(100) {
        fmt.Println(num)
    }
}
```

# <font style="color:rgb(0, 0, 0);">其他独特语法</font>
## <font style="color:rgb(0, 0, 0);">海象运算符 (Walrus Operator) 3.8+</font>
```python
# 在表达式中赋值
if (n := len(data)) > 10:
    print(f"数据过长 ({n} 项)")

# 替代传统写法
n = len(data)
if n > 10:
    print(f"数据过长 ({n} 项)")
```

## <font style="color:rgb(0, 0, 0);">多变量赋值</font>
```python
# 交换变量
a, b = 1, 2
a, b = b, a  # a=2, b=1

# 解包操作
data = [1, 2, 3]
x, y, z = data
```

Go 对比（需临时变量）

```go
a, b := 1, 2
a, b = b, a  // Go 也支持
```

## <font style="color:rgb(0, 0, 0);">函数参数解包</font>
```python
def sum_all(a, b, c):
    return a + b + c

nums = [1, 2, 3]
print(sum_all(*nums))  # 6

kwargs = {'a': 2, 'b': 3, 'c': 4}
print(sum_all(**kwargs))  # 9
```

#Go 无直接对应语法，需手动展开

```go
func sumAll(a, b, c int) int {
    return a + b + c
}

nums := []int{1, 2, 3}
sumAll(nums[0], nums[1], nums[2])
```

# <font style="color:rgb(0, 0, 0);">总结对比</font>
| **<font style="color:rgb(0, 0, 0);">特性</font>** | **<font style="color:rgb(0, 0, 0);">Python 方案</font>** | **<font style="color:rgb(0, 0, 0);">Go 替代方案</font>** | **<font style="color:rgb(0, 0, 0);">核心差异</font>** |
| :--- | :--- | :--- | :--- |
| <font style="color:rgb(0, 0, 0);">代码组织</font> | <font style="color:rgb(0, 0, 0);">模块化 + 灵活导入</font> | <font style="color:rgb(0, 0, 0);">包系统 + 严格可见性</font> | <font style="color:rgb(0, 0, 0);">Python 更灵活，Go 更严谨</font> |
| <font style="color:rgb(0, 0, 0);">语法糖</font> | <font style="color:rgb(0, 0, 0);">丰富的推导式、装饰器等</font> | <font style="color:rgb(0, 0, 0);">较少语法糖，强调显式</font> | <font style="color:rgb(0, 0, 0);">Python 提升开发效率</font> |
| <font style="color:rgb(0, 0, 0);">元编程</font> | <font style="color:rgb(0, 0, 0);">装饰器、元类等强大支持</font> | <font style="color:rgb(0, 0, 0);">通过接口和反射有限支持</font> | <font style="color:rgb(0, 0, 0);">Python 更适合动态场景</font> |
| <font style="color:rgb(0, 0, 0);">并发模型</font> | <font style="color:rgb(0, 0, 0);">多线程 + GIL 限制</font> | <font style="color:rgb(0, 0, 0);">Goroutine + Channel</font> | <font style="color:rgb(0, 0, 0);">Go 并发性能更优</font> |


**<font style="color:rgb(0, 0, 0);">学习建议</font>**<font style="color:rgb(0, 0, 0);">：</font>

+ **<font style="color:rgb(0, 0, 0);">Python</font>**<font style="color:rgb(0, 0, 0);">：掌握推导式、装饰器、上下文管理器等高效语法</font>
+ **<font style="color:rgb(0, 0, 0);">Go</font>**<font style="color:rgb(0, 0, 0);">：深入理解接口、并发模型和显式错误处理</font>
+ **<font style="color:rgb(0, 0, 0);">交叉学习</font>**<font style="color:rgb(0, 0, 0);">：理解两种语言的设计哲学差异（Python 的 “Batteries Included” vs Go 的 “Less is More”）</font>

<font style="color:rgb(0, 0, 0);">通过对比学习，可以更深刻地理解两种语言的优势领域：Python 适合快速开发和脚本任务，Go 则擅长构建高性能并发系统。</font>

