装饰器的核心优势在于 **非侵入式地扩展功能**，以下通过 7 个典型场景的代码示例，展示其在实际开发中的独特价值：

#  功能复用：告别重复代码
**场景**：多个函数需要添加执行时间统计

**传统写法**（重复代码）：

```python
def func1():
    start = time.time()
    # ...业务逻辑...
    print(f"耗时: {time.time()-start:.2f}s")

def func2():
    start = time.time()
    # ...业务逻辑...
    print(f"耗时: {time.time()-start:.2f}s")
```

**装饰器方案**（消除重复）：

```python
def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        print(f"{func.__name__} 耗时: {time.time()-start:.2f}s")
        return result
    return wrapper

@timer
def func1():
    # ...业务逻辑...

@timer
def func2():
    # ...业务逻辑...
```

# 权限控制：统一校验逻辑
**场景**：Web API 接口的登录验证

**装饰器实现**：

```python
def login_required(func):
    def wrapper(request, *args, **kwargs):
        if not request.user.is_authenticated:
            return HttpResponseRedirect("/login/")
        return func(request, *args, **kwargs)
    return wrapper

@login_required
def user_profile(request):
    return render(request, 'profile.html')

@login_required
def order_history(request):
    return render(request, 'orders.html')
```

# 缓存优化：提升性能
**场景**：缓存函数计算结果

**装饰器方案**：

```python
from functools import lru_cache

@lru_cache(maxsize=128)
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# 计算斐波那契数列时自动缓存中间结果
print(fibonacci(50))  # 快速计算结果
```

# 失败重试：增强容错性
**场景**：网络请求失败自动重试

**装饰器实现**：

```python
import requests
from time import sleep

def retry(max_attempts=3, delay=1):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_attempts-1:
                        raise
                    print(f"第 {attempt+1} 次重试: {e}")
                    sleep(delay)
        return wrapper
    return decorator

@retry(max_attempts=5, delay=2)
def fetch_data(url):
    response = requests.get(url)
    response.raise_for_status()
    return response.json()
```

# 路由注册：简化框架开发
**场景**：Web 框架的路由系统（类似 Flask）

**装饰器方案**：

```python
class WebFramework:
    def __init__(self):
        self.routes = {}

    def route(self, path):
        def decorator(func):
            self.routes[path] = func
            return func
        return decorator

app = WebFramework()

@app.route("/")
def home():
    return "Home Page"

@app.route("/about")
def about():
    return "About Us"

# 自动生成路由表：{'/': home, '/about': about}
```

# 输入验证：保证数据安全
**场景**：验证 API 输入参数

**装饰器实现**：

```python
def validate_input(schema):
    def decorator(func):
        def wrapper(data):
            # 执行 schema 验证逻辑
            if not schema.validate(data):
                raise ValueError("非法输入")
            return func(data)
        return wrapper
    return decorator

user_schema = Schema(...)  # 定义验证规则

@validate_input(user_schema)
def create_user(data):
    # 确保此处 data 已通过验证
    db.insert(data)
```

# 性能分析：定位瓶颈
**场景**：分析函数内存和耗时

**装饰器方案**：

```python
import tracemalloc
import time

def profile(func):
    def wrapper(*args, **kwargs):
        # 内存分析
        tracemalloc.start()
        # 时间分析
        start_time = time.perf_counter()
        
        result = func(*args, **kwargs)
        
        # 输出报告
        elapsed = time.perf_counter() - start_time
        current, peak = tracemalloc.get_traced_memory()
        print(f"{func.__name__}:")
        print(f"耗时: {elapsed:.4f}s")
        print(f"内存占用: {current / 1024:.2f}KB (峰值 {peak / 1024:.2f}KB)")
        tracemalloc.stop()
        return result
    return wrapper

@profile
def process_data(data):
    # 数据处理逻辑
    return transformed_data
```

# 核心优势总结
| 优势 | 传统方案痛点 | 装饰器解决方案 |
| --- | --- | --- |
| **代码复用** | 相同逻辑重复编写 | 一次定义，多处 `@` 调用 |
| **关注点分离** | 业务代码混杂非核心逻辑 | 主逻辑保持纯净 |
| **动态扩展** | 需修改原函数代码 | 非侵入式添加/移除功能 |
| **配置灵活** | 硬编码参数难以修改 | 通过装饰器参数动态配置 |
| **可维护性** | 功能修改需全局搜索替换 | 集中维护装饰器逻辑 |
| **可读性** | 业务逻辑被辅助代码淹没 | 通过 `@` 声明功能一目了然 |


**实际开发建议**：将装饰器视为代码的「功能插件」，用于处理日志、权限、缓存、监控等 **横切关注点**（Cross-Cutting Concerns），保持核心业务逻辑的简洁性。

