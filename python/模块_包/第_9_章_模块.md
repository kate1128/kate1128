[模块_包.pdf](https://www.yuque.com/attachments/yuque/0/2025/pdf/2639475/1753151264301-747bf390-2d6c-4a92-afbd-78847f62a2e8.pdf)

# <font style="color:rgb(0,0,0);"> 简介 </font>
<font style="color:rgb(0,0,0);">你已经学习了如何在你的程序中定义一次函数而重用代码。如果你想要在其他程序中重用很多函数，那么你该如何编写程序呢？你可能已经猜到了，答案是使用模块。 </font>

<font style="color:rgb(0,0,0);">编写模块有各种各样的方法，但最简单的方法就是创建以 .py 为扩展名的文件，在文件中包含函数和变量。 </font>

<font style="color:rgb(0,0,0);">另外一个编写模块的方法就是用自然语言，就是以 Python 编译器本身的方式写。例如，你可以用 C 语言写模块（</font>[https://docs.python.org/3/extending/](https://docs.python.org/3/extending/)<font style="color:rgb(0,0,0);">），当编译时，使用标准 Python 编译器时，可以在 Python 代码使用。 </font>

<font style="color:rgb(0,0,0);">模块可以从另外一个程序导入来使用其函数的功能。这也是我们使用 Python 标准库的方式。首先，看一看如何使用标准库模块。 </font>

<font style="color:rgb(0,0,0);">例子： </font>

```python
#!/usr/bin/python 
# Filename: using_sys.py 
 
import sys  
print('The command line arguments are:') 

for i in sys.argv: 
    print(i) 

print('\n\nThe PYTHONPATH is', sys.path, '\n') 
```

<font style="color:rgb(0,0,0);">输出： </font>

```python
PS C:\Users\12983\workspace\python_AITest> python test.py we are arguments     
The command line arguments are:
test.py
we
are
arguments


The PYTHONPATH is ['C:\\Users\\12983\\workspace\\python_AITest', 'C:\\Users\\12983\\AppData\\Local\\Programs\\Python\\Python313\\python313.zip', 'C:\\Users\\12983\\AppData\\Local\\Programs\\Python\\Python313\\DLLs', 'C:\\Users\\12983\\AppData\\Local\\Programs\\Python\\Python313\\Lib', 'C:\\Users\\12983\\AppData\\Local\\Programs\\Python\\Python313', 'C:\\Users\\12983\\workspace\\python_AITest\\myenv', 'C:\\Users\\12983\\workspace\\python_AITest\\myenv\\Lib\\site-packages']
```

<font style="color:rgb(0,0,0);">如何工作： </font>

<font style="color:rgb(0,0,0);">首先，用导入了 </font>`<font style="color:rgb(0,0,0);">sys</font>`<font style="color:rgb(0,0,0);"> 模块。基本上，这句语句告诉 Python ，我们想要使用这个模块。 </font>`<font style="color:rgb(0,0,0);">sys</font>`<font style="color:rgb(0,0,0);"> 模块包含了与 Python 解释器和它的环境有关的函数。 </font>

<font style="color:rgb(0,0,0);">当 Python 执行</font>`<font style="color:rgb(0,0,0);"> import sys </font>`<font style="color:rgb(0,0,0);">语句的时候，它会寻找 sys 模块。在这个例子中，它是内置模块，因此 Python 知道在哪里找到它。 </font>

<font style="color:rgb(0,0,0);">如果它是未编译的模块，如用 Python 写的模块， Python 解释器会查找列在</font>`<font style="color:rgb(0,0,0);"> sys.path </font>`<font style="color:rgb(0,0,0);">变量中的路径。如果模块找到了，就会运行那个模块主体中的语句， 模块就是可以利用的了。注意，初始化过程仅在我们第一次导入模块的时候进行。 </font>

<font style="color:rgb(0,0,0);">在 sys 模块中，</font>`<font style="color:rgb(0,0,0);">argv</font>`<font style="color:rgb(0,0,0);"> 变量可以用</font>`<font style="color:rgb(0,0,0);"> sys.argv </font>`<font style="color:rgb(0,0,0);">来引用。它很清楚地表明这个名字是 sys 模块中的一部分。这种方法的一个优势是这个名称不会与任何在你的程序中使用的 argv 变量冲突。另 </font>`<font style="color:rgb(0,0,0);">sys.argv </font>`<font style="color:rgb(0,0,0);">变量是一个字符串的列表（列表会在后面的章节详细解释）。特别地，</font>`<font style="color:rgb(0,0,0);">sys.argv </font>`<font style="color:rgb(0,0,0);">包含了命令行参数的列表，即使用命令行传递给你的程序的参数。 </font>

<font style="color:rgb(0,0,0);">如果你使用 IDE 编写运行这些程序，请在菜单里寻找一个指定程序的命令行参数的方法。 </font>

<font style="color:rgb(0,0,0);">这里，当我们执行 </font>`<font style="color:rgb(0,0,0);">python using_sys.py we are arguments </font>`<font style="color:rgb(0,0,0);">的时候，我们使用 python命令运行</font>`<font style="color:rgb(0,0,0);"> using_sys.py </font>`<font style="color:rgb(0,0,0);">模块，后面跟着的内容被作为参数传递给程序。 Python 为我们把它存储在</font>`<font style="color:rgb(0,0,0);"> sys.argv </font>`<font style="color:rgb(0,0,0);">变量中。 </font>

<font style="color:rgb(0,0,0);">记住，脚本的名称总是</font>`<font style="color:rgb(0,0,0);"> sys.argv </font>`<font style="color:rgb(0,0,0);">列表的第一个参数。所以，在这里，</font>`<font style="color:rgb(0,0,0);">’using_sys.py’</font>`<font style="color:rgb(0,0,0);">是</font>`<font style="color:rgb(0,0,0);"> sys.argv[0]</font>`<font style="color:rgb(0,0,0);">、</font>`<font style="color:rgb(0,0,0);">’we’</font>`<font style="color:rgb(0,0,0);"> 是</font>`<font style="color:rgb(0,0,0);"> sys.argv[1]</font>`<font style="color:rgb(0,0,0);">、</font>`<font style="color:rgb(0,0,0);">’are’ </font>`<font style="color:rgb(0,0,0);">是 </font>`<font style="color:rgb(0,0,0);">sys.argv[2] </font>`<font style="color:rgb(0,0,0);">以及</font>`<font style="color:rgb(0,0,0);">’arguments’ </font>`<font style="color:rgb(0,0,0);">是</font>`<font style="color:rgb(0,0,0);">sys.argv[3]</font>`<font style="color:rgb(0,0,0);">。 </font>

<font style="color:rgb(0,0,0);">注意，Python 从 0 开始计数，而非从 1 开始。 </font>

`<font style="color:rgb(0,0,0);">sys.path </font>`<font style="color:rgb(0,0,0);">包含输入模块的目录名列表。我们可以观察到 </font>`<font style="color:rgb(0,0,0);">sys.path</font>`<font style="color:rgb(0,0,0);"> 的第一个字符串是空的，这个空的字符串表示当前目录也是 </font>`<font style="color:rgb(0,0,0);">sys.path</font>`<font style="color:rgb(0,0,0);"> 的一部分，这与 </font>`<font style="color:rgb(0,0,0);">PYTHONPATH</font>`<font style="color:rgb(0,0,0);"> 环境变量是相同的。这意味着你可以直接输入位于当前目录的模块。否则，你得把你的模块放在 </font>`<font style="color:rgb(0,0,0);">sys.path </font>`<font style="color:rgb(0,0,0);">所列的目录之一。 </font>

<font style="color:rgb(0,0,0);">注意，当前目录是程序启动的目录。运行</font>`<font style="color:rgb(0,0,0);"> import os; print(os.getcwd()) </font>`<font style="color:rgb(0,0,0);">来查询你的程序的当前目录。 </font>

# <font style="color:rgb(0,0,0);"> 按字节编译的 .pyc 文件 </font>
<font style="color:rgb(0,0,0);">导入一个模块相对来说是一个比较费时的事情，所以 Python 做了一些技巧，以便使输入模块更加快一些。一种方法是创建按字节编译的文件，这些文件以.pyc 作为扩展名。字节编译的文件与 Python 变换程序的中间状态有关（是否还记得 Python 如何工作的介绍？）。</font>

<font style="color:rgb(0,0,0);">当你在下次从别的程序输入这个模块的时候，.pyc 文件是十分有用的，它会快得多，因为一部分输入模块所需的处理已经完成了。另外，这些字节编译的文件也是与平台无关的。所以，现在你知道了那些.pyc 文件事实上是什么了。 </font>

**<font style="color:rgb(0,0,0);">注释： </font>**

<font style="color:rgb(0,0,0);">这些.pyc 文件通常与.py 文件相同的方式在相同路径被创建。如果 Python 没有写入当前路径的权限，.pyc 文件就不会被创建。 </font>

# <font style="color:rgb(0,0,0);"></font>`<font style="color:rgb(0,0,0);">from...import... </font>`<font style="color:rgb(0,0,0);">语句 </font>
<font style="color:rgb(0,0,0);">如果你想要直接输入 </font>`<font style="color:rgb(0,0,0);">argv</font>`<font style="color:rgb(0,0,0);"> 变量到你的程序中（避免在每次使用它时打 sys.），那么你可以使用</font>`<font style="color:rgb(0,0,0);"> from sys import argv </font>`<font style="color:rgb(0,0,0);">语句。如果你想要输入所有 sys 模块使用的名字，那么你可以使用</font>`<font style="color:rgb(0,0,0);"> from sys import *</font>`<font style="color:rgb(0,0,0);"> 语句。这对于所有模块都适用。 </font>

<font style="color:rgb(0,0,0);">一般说来，应该避免使用</font>`<font style="color:rgb(0,0,0);"> from..import </font>`<font style="color:rgb(0,0,0);">而使用 </font>`<font style="color:rgb(0,0,0);">import</font>`<font style="color:rgb(0,0,0);"> 语句，因为这样可以使你的程序更加易读，也可以避免名称的冲突。 </font>

# <font style="color:rgb(0,0,0);"> 模块的 </font>`<font style="color:rgb(0,0,0);">__name__ </font>`
<font style="color:rgb(0,0,0);">每个模块都有一个名称，在模块中可以通过语句来找出模块的名称。</font>

<font style="color:rgb(0,0,0);">这在一个场合特别有用 ，就如前面所提到的，当一个模块被第一次输入的时候，这个模块的主块将被运行。假如我们只想在程序本身被使用的时候运行主块，而在它被别的模块输入的时候不运行主块，我们该怎么做呢？这可以通过模块的 </font>`<font style="color:rgb(0,0,0);">__name__</font>`<font style="color:rgb(0,0,0);"> 属性完成。 </font>

<font style="color:rgb(0,0,0);">例子： </font>

```python
#!/usr/bin/python 
# Filename: using_name.py 

if __name__ == '__main__': 
    print('This program is being run by itself') 
else: 
    print('I am being imported from another module') 
```

<font style="color:rgb(0,0,0);">输出：</font>

```python
 $ python using_name.py 
This program is being run by itself 
 
$ python 
>>> import using_name 
I am being imported from another module 
>>> 
```

<font style="color:rgb(0,0,0);">如何工作： </font>

<font style="color:rgb(0,0,0);">每个 Python 模块都有它的 </font>`<font style="color:rgb(0,0,0);">__name__</font>`<font style="color:rgb(0,0,0);">，如果它是’</font>`<font style="color:rgb(0,0,0);">__main__</font>`<font style="color:rgb(0,0,0);">’，这说明这个模块被用户单独运行，我们可以进行相应的恰当操作。 </font>

# <font style="color:rgb(0,0,0);"> 创建自己的模块 </font>
<font style="color:rgb(0,0,0);">创建你自己的模块是十分简单的，你一直在这样做！每个 Python 程序也是一个模块。你已经确保它具有</font>`<font style="color:rgb(0,0,0);">.py </font>`<font style="color:rgb(0,0,0);">扩展名了。下面这个例子将会使它更加清晰。 </font>

<font style="color:rgb(0,0,0);">例子： </font>

```python
#!/usr/bin/python 
# Filename: mymodule.py 
def sayhi(): 
    print('Hi, this is mymodule speaking.') 

__version__ = '0.1'  
# End of mymodule.py 
```

<font style="color:rgb(0,0,0);">上面是一个模块的例子。你已经看到，它与我们普通的 Python 程序相比并没有什么特别之处。我们接下来将看看如何在我们别的 Python 程序中使用这个模块。 </font>

<font style="color:rgb(0,0,0);">记住这个模块应该被放置在我们输入它的程序的同一个目录中，或者在 sys.path所列目录之一。 </font>

```python
#!/usr/bin/python  
# Filename: mymodule_demo.py 
 
import mymodule 
mymodule.sayhi() 
print ('Version', mymodule.__version__) 
```

<font style="color:rgb(0,0,0);">输出： </font>

```python
$ python mymodule_demo.py 
Hi, this is mymodule speaking. 
Version 0.1 
```

<font style="color:rgb(0,0,0);">如何工作： </font>

<font style="color:rgb(0,0,0);">注意我们使用了相同的点号来使用模块的成员。Python 很好地重用了相同的记号来，使我们这些 Python 程序员不需要不断地学习新的方法。 </font>

<font style="color:rgb(0,0,0);">下面是一个使用 from..import 语法的版本。 </font>

```python
#!/usr/bin/python 
# Filename: mymodule_demo2.py 

from mymodule import sayhi, __version__  
sayhi()  
print('Version', __version__) 
```

`<font style="color:rgb(0,0,0);">mymodule_demo2.py </font>`<font style="color:rgb(0,0,0);">的输出与 </font>`<font style="color:rgb(0,0,0);">mymodule_demo.py </font>`<font style="color:rgb(0,0,0);">完全相同。 </font>

<font style="color:rgb(0,0,0);">注意如果已经在导入 </font>`<font style="color:rgb(0,0,0);">mymodule</font>`<font style="color:rgb(0,0,0);"> 的模块中申明了一个 </font>`<font style="color:rgb(0,0,0);">__version__</font>`<font style="color:rgb(0,0,0);"> 的名字，这就会有冲突。这也是有可能的，因为从实际情况来看，每个模块会用这个名字来申明它的版本。因此，推荐选择使用 </font>`<font style="color:rgb(0,0,0);">import</font>`<font style="color:rgb(0,0,0);"> 语句，虽然会导致程序稍微有点冗长。 </font>

<font style="color:rgb(0,0,0);">你也可以这样使用： </font>

```python
from mymodule import * 
```

<font style="color:rgb(0,0,0);">这回导入像 sayhi 这样公用的名字，但不会导入 </font>`<font style="color:rgb(0,0,0);">__version__</font>`<font style="color:rgb(0,0,0);">，因为它是以双下划线开始的。 </font>

**<font style="color:rgb(0,0,0);">Python </font>****<font style="color:rgb(0,0,0);">之⾻ </font>**

<font style="color:rgb(0,0,0);">Python 的一个指导原则是“直白优于含蓄”。运行</font>`<font style="color:rgb(0,0,0);"> import this </font>`<font style="color:rgb(0,0,0);">来学习更多，看关于这个的讨论 （</font>[https://stackoverflow.com/questions/228181/the-zen-of-python](https://stackoverflow.com/questions/228181/the-zen-of-python)<font style="color:rgb(0,0,0);">），这儿列举了每个原则的例子。 </font>

# <font style="color:rgb(0,0,0);">dir 函数 </font>
<font style="color:rgb(0,0,0);">你可以使用内建的 dir 函数来列出模块定义的标识符。标识符有函数、类和变量。 </font>

<font style="color:rgb(0,0,0);">当你为</font>`<font style="color:rgb(0,0,0);"> dir() </font>`<font style="color:rgb(0,0,0);">提供一个模块名的时候，它返回模块定义的名称列表。如果不提供参数，它返回当前模块中定义的名称列表。 </font>

<font style="color:rgb(0,0,0);">例子： </font>

```python

>>> import sys
>>> dir(sys)
['__breakpointhook__', '__displayhook__', '__doc__', '__excepthook__', '__interactivehook__', '__loader__', '__name__', '__package__', '__spec__', '__stderr__', '__stdin__', '__stdout__', '__unraisablehook__', '_base_executable', '_baserepl', '_cached_windows_version', '_clear_internal_caches', '_clear_type_cache', '_current_exceptions', '_current_frames', '_debugmallocstats', '_enablelegacywindowsfsencoding', '_framework', '_get_cpu_count_config', '_getframe', '_getframemodulename', '_git', '_home', '_is_gil_enabled', '_is_interned', '_setprofileallthreads', '_settraceallthreads', '_stdlib_dir', '_vpath', '_xoptions', 'activate_stack_trampoline', 'addaudithook', 'api_version', 'argv', 'audit', 'base_exec_prefix', 'base_prefix', 'breakpointhook', 'builtin_module_names', 'byteorder', 'call_tracing', 'copyright', 'deactivate_stack_trampoline', 'displayhook', 'dllhandle', 'dont_write_bytecode', 'exc_info', 'excepthook', 'exception', 'exec_prefix', 'executable', 'exit', 'flags', 'float_info', 'float_repr_style', 'get_asyncgen_hooks', 'get_coroutine_origin_tracking_depth', 'get_int_max_str_digits', 'getallocatedblocks', 'getdefaultencoding', 'getfilesystemencodeerrors', 'getfilesystemencoding', 'getprofile', 'getrecursionlimit', 'getrefcount', 'getsizeof', 'getswitchinterval', 'gettrace', 'getunicodeinternedsize', 'getwindowsversion', 'hash_info', 'hexversion', 'implementation', 'int_info', 'intern', 'is_finalizing', 'is_stack_trampoline_active', 'last_exc', 'last_traceback', 'last_type', 'last_value', 'maxsize', 'maxunicode', 'meta_path', 'modules', 'monitoring', 'orig_argv', 'path', 'path_hooks', 'path_importer_cache', 'platform', 'platlibdir', 'prefix', 'ps1', 'ps2', 'pycache_prefix', 'set_asyncgen_hooks', 'set_coroutine_origin_tracking_depth', 'set_int_max_str_digits', 'setprofile', 'setrecursionlimit', 'setswitchinterval', 'settrace', 'stderr', 'stdin', 'stdlib_module_names', 'stdout', 'thread_info', 'unraisablehook', 'version', 'version_info', 'warnoptions', 'winver']
>>> dir()
['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'sys', 'test']        
>>> a=5
>>> dir()
['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'sys', 'test']   
>>> del a
>>> dir()
['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'sys', 'test']        
>>> 
```

![](https://cdn.nlark.com/yuque/0/2024/png/2639475/1731757223392-a4dda6e9-e74c-4980-b20a-2a41c1176725.png)

<font style="color:rgb(0,0,0);">如何工作： </font>

<font style="color:rgb(0,0,0);">首先，我们来看一下在输入的 sys 模块上使用 dir。我们看到它包含一个庞大的属性列表。 </font>

<font style="color:rgb(0,0,0);">接下来，我们不给 dir 函数传递参数而使用它，默认地，它返回当前模块的属性列表。注意，输入的模块同样是列表的一部分。 </font>

<font style="color:rgb(0,0,0);">为了观察 dir 的作用，我们定义一个新的变量 a 并且给它赋一个值，然后检验dir，我们观察到在列表中增加了以上相同的值。我们使用 del 语句删除当前模块中的变量/属性，这个变化再一次反映在 dir 的输出中。 </font>

<font style="color:rgb(0,0,0);">关于 del 的注释， 该语句用于删除变量/名字，在运行语句后，在这个例子中，</font>`<font style="color:rgb(0,0,0);">del a</font>`<font style="color:rgb(0,0,0);">，你将无法再使用变量 a，它就好像从来没有存在过一样。 </font>

<font style="color:rgb(0,0,0);">注意 dir() 函数能在任何对象上起作用。例如，运行 </font>`<font style="color:rgb(0,0,0);">dri(print) </font>`<font style="color:rgb(0,0,0);">来了解关于 </font>`<font style="color:rgb(0,0,0);">print</font>`<font style="color:rgb(0,0,0);"> 函数的属性，或者</font>`<font style="color:rgb(0,0,0);"> dir(str) </font>`<font style="color:rgb(0,0,0);">来查看 str 类的属性。 </font>

# <font style="color:rgb(0,0,0);"> 包 </font>
<font style="color:rgb(0,0,0);">到目前为止，你一定已经开始看到了组织你的程序的层次。变量通常在函数内部运行。函数和全局变量通常在模块内部运行。如果你想自己组织模块呢？那" 包" 就会进入到你的视野中。 </font>

<font style="color:rgb(0,0,0);">包是模块的文件夹，有一个特殊的</font>`<font style="color:rgb(0,0,0);"> __init__.py </font>`<font style="color:rgb(0,0,0);">文件，用来表明这个文件夹是特殊的因为其包含有 Python 模块。 </font>

<font style="color:rgb(0,0,0);">加入你想创建一个叫做’</font>`<font style="color:rgb(0,0,0);">world</font>`<font style="color:rgb(0,0,0);">’ 的包，有子包’</font>`<font style="color:rgb(0,0,0);">asia</font>`<font style="color:rgb(0,0,0);">’,’</font>`<font style="color:rgb(0,0,0);">africa</font>`<font style="color:rgb(0,0,0);">’ 等等，并且，这些子包又包含模块，如’</font>`<font style="color:rgb(0,0,0);">india</font>`<font style="color:rgb(0,0,0);">’,’</font>`<font style="color:rgb(0,0,0);">madagascar</font>`<font style="color:rgb(0,0,0);">’ 等等。 </font>

<font style="color:rgb(0,0,0);">这就是你像构造的文件夹： </font>

```bash
- <some folder present in the sys.path>/
    - world/
        - __init__.py
        - asia/
            - __init__.py
            - india/
                - __init__.py
                - foo.py
        - africa/
            - __init__.py
            - madagascar/
                - __init__.py
                - bar.py
```

<font style="color:rgb(0,0,0);">包仅仅是为了方便层次化地组织模块。你会看到在</font>[标准库](https://python.swaroopch.com/stdlib.html#stdlib)<font style="color:rgb(0,0,0);">中看到许多这样的实例。 </font>

# <font style="color:rgb(0,0,0);"> 概括 </font>
<font style="color:rgb(0,0,0);">就像函数是在程序块中能在利用一样，模块是可在利用的程序。包是另一个组织模块的层次。伴随 Python 的标准库是这样一个包集和模块的例子。 已经看到了如何使用模块并且创建自己的模块。 </font>

<font style="color:rgb(0,0,0);"></font>

