<font style="color:rgb(0,0,0);">我们已经探讨了 Python 语言的各个部分，现在就来看看如何通过设计和编写一个能做有用事情的程序来将这些部分结合到一起。思路就是学习如何写你自己的一个 Python 脚本。 </font>

# <font style="color:rgb(0,0,0);">问题 </font>
<font style="color:rgb(0,0,0);">问题是“我想写一个能给我所有重要文件建立备份的程序”。 </font><font style="color:rgb(0,0,0);">尽管这是一个简单的问题，但是问题本身并没有给我们足够的信息来解决它。进一步的分析是必需的。例如，我们如何确定该备份哪些文件？备份保存在哪里？我们怎么样存储备份？ </font>

<font style="color:rgb(0,0,0);">在恰当地分析了这个问题之后，我们开始设计我们的程序。</font>

<font style="color:rgb(0,0,0);">我们列了一张表，表示我们的程序应该如何工作。对于这个问题，我已经创建了下面这个列表以说明我如何让它工作。</font>

1. <font style="color:rgb(0,0,0);">需要备份的文件和目录由一个列表指定。 </font>
2. <font style="color:rgb(0,0,0);">备份应该保存在主备份目录中。 </font>
3. <font style="color:rgb(0,0,0);">文件备份成一个 zip 文件。 </font>
4. <font style="color:rgb(0,0,0);">zip 存档的名称是当前的日期和时间。 </font>
5. <font style="color:rgb(0,0,0);">我们使用标准的 zip 命令，它通常默认地随 Linux/Unix 发行版提供。Windows用户可以从</font>[GnuWin32](https://gnuwin32.sourceforge.net/packages/zip.htm)<font style="color:rgb(0,0,0);">项目页安装。注意你可以使用任何存档命令，只要它有命令行界面就可以了，那样的话我们可以从我们的脚本中传递参数给它。 </font>

# <font style="color:rgb(0,0,0);">解决方案 </font>
<font style="color:rgb(0,0,0);">由于程序的设计现在来说是相对稳定的，我们可以写出这些代码，这就是解决方案的实现。（译者注：下面的程序并不一定能直接运行，还需手动修改一些相关参数）。 </font>

```python
#!/usr/bin/python 
# Filename: backup_ver1.py 
import os
import time

# 1. The files and directories to be backed up are
# specified in a list.
# Example on Windows:
# source = ['"C:\\My Documents"']
# Example on Mac OS X and Linux:
source = ['/Users/swa/notes']
# Notice we have to use double quotes inside a string
# for names with spaces in it.  We could have also used
# a raw string by writing [r'C:\My Documents'].

# 2. The backup must be stored in a
# main backup directory
# Example on Windows:
# target_dir = 'E:\\Backup'
# Example on Mac OS X and Linux:
target_dir = '/Users/swa/backup'
# Remember to change this to which folder you will be using

# 3. The files are backed up into a zip file.
# 4. The name of the zip archive is the current date and time
target = target_dir + os.sep + \
         time.strftime('%Y%m%d%H%M%S') + '.zip'

# Create target directory if it is not present
if not os.path.exists(target_dir):
    os.mkdir(target_dir)  # make directory

# 5. We use the zip command to put the files in a zip archive
zip_command = 'zip -r {0} {1}'.format(target,
                                      ' '.join(source))

# Run the backup
print('Zip command is:')
print(zip_command)
print('Running:')
if os.system(zip_command) == 0:
    print('Successful backup to', target)
else:
    print('Backup FAILED')
```

输出 :

```python
$ python backup_ver1.py
Zip command is:
zip -r /Users/swa/backup/20140328084844.zip /Users/swa/notes
Running:
  adding: Users/swa/notes/ (stored 0%)
  adding: Users/swa/notes/blah1.txt (stored 0%)
  adding: Users/swa/notes/blah2.txt (stored 0%)
  adding: Users/swa/notes/blah3.txt (stored 0%)
Successful backup to /Users/swa/backup/20140328084844.zip
```

<font style="color:rgb(0,0,0);">现在，我们已经处于测试环节了，在这个环节，我们测试我们的程序是否正确工作。如果它与我们所期望的不一样，我们就得调试我们的程序，即消除程序中的 bugs（错误）。 </font>

<font style="color:rgb(0,0,0);">如果上面的程序没有工作，在 </font>`<font style="color:rgb(0,0,0);">os.system</font>`<font style="color:rgb(0,0,0);"> 命令之前设置一条语句 </font>`<font style="color:rgb(0,0,0);">print(zip_command)</font>`<font style="color:rgb(0,0,0);">，然后运行程序。现在复制/粘贴打印出来的 </font>`<font style="color:rgb(0,0,0);">zip_command</font>`<font style="color:rgb(0,0,0);"> 到 shell 提示符，看一看能否正常运行。如果命令失败，检查 </font>`<font style="color:rgb(0,0,0);">zip</font>`<font style="color:rgb(0,0,0);"> 命令手册到底是什么出错了。如果命令正常，检查 Python 程序，看它是不是与上面写出的程序一致。 </font>

<font style="color:rgb(0,0,0);">如何工作： </font>

<font style="color:rgb(0,0,0);">接下来你将看到我们如何把设计一步一步地转换为代码。 </font>

<font style="color:rgb(0,0,0);">我们使用了 </font>`<font style="color:rgb(0,0,0);">os</font>`<font style="color:rgb(0,0,0);"> 和 </font>`<font style="color:rgb(0,0,0);">time</font>`<font style="color:rgb(0,0,0);"> 模块，所以我们输入它们。然后，我们在 source 列表中指定需要备份的文件和目录。目标目录是我们想要存储备份文件的地方，它由 </font>`<font style="color:rgb(0,0,0);">target_dir</font>`<font style="color:rgb(0,0,0);">变量指定。zip 归档的名称是目前的日期和时间，我们使用</font>`<font style="color:rgb(0,0,0);"> time.strftime() </font>`<font style="color:rgb(0,0,0);">函数获得。 </font>

<font style="color:rgb(0,0,0);">它还包括</font>`<font style="color:rgb(0,0,0);">.zip </font>`<font style="color:rgb(0,0,0);">扩展名，将被保存在 </font>`<font style="color:rgb(0,0,0);">target_dir</font>`<font style="color:rgb(0,0,0);"> 目录中。 </font>

<font style="color:rgb(0,0,0);">注意</font>`<font style="color:rgb(0,0,0);"> os.sep </font>`<font style="color:rgb(0,0,0);">变量的使用 —— 这回根据你的操作系统给出路径分割符，例如在 Linux、Unix 中用</font>`<font style="color:rgb(0,0,0);">'/'</font>`<font style="color:rgb(0,0,0);">，在 windows 中用</font>`<font style="color:rgb(0,0,0);">'\\'</font>`<font style="color:rgb(0,0,0);">，在 Mac OS 中用</font>`<font style="color:rgb(0,0,0);">':'</font>`<font style="color:rgb(0,0,0);">。使用</font>`<font style="color:rgb(0,0,0);"> os.sep </font>`<font style="color:rgb(0,0,0);">而不是直接使用这些符号会使你的程序更简洁，并且能在这些系统下正常工作。 </font>

`<font style="color:rgb(0,0,0);">time.strftime() </font>`<font style="color:rgb(0,0,0);">函数需要我们在上面的程序中使用的那种定制。</font>`<font style="color:rgb(0,0,0);">%Y </font>`<font style="color:rgb(0,0,0);">会被无世纪的年份所替代。</font>`<font style="color:rgb(0,0,0);"> % m </font>`<font style="color:rgb(0,0,0);">会被</font>`<font style="color:rgb(0,0,0);"> 01</font>`<font style="color:rgb(0,0,0);"> 到</font>`<font style="color:rgb(0,0,0);"> 12 </font>`<font style="color:rgb(0,0,0);">之间的一个十进制月份数替代，其他依次类推。这些定制的详细情况可以在 </font>[《Python 参考手册》](https://docs.python.org/3/library/time.html#time.strftime)<font style="color:rgb(0,0,0);">中获得。 </font>

<font style="color:rgb(0,0,0);">我们用添加操作（该操作多个字符串连接到一起，例如，将两个字符串练到一起然后返回返回一个新的串）创建了名为</font>`<font style="color:rgb(0,0,0);"> target.zip </font>`<font style="color:rgb(0,0,0);">的文件。然后，创建了一个 </font>`<font style="color:rgb(0,0,0);">zip_command</font>`<font style="color:rgb(0,0,0);"> 字符串，这个字符串包含了将要执行的命令。你可以通过在 shell 中 （Linux 终端或 DOS 提示符）运行来检查命令的正确性。 </font>

<font style="color:rgb(0,0,0);">使用的 </font>`<font style="color:rgb(0,0,0);">zip</font>`<font style="color:rgb(0,0,0);"> 命令有一些选项和传递的参数。</font>`<font style="color:rgb(0,0,0);">-q </font>`<font style="color:rgb(0,0,0);">选项被用来表明 zip 命令应该以快速的方式进行。</font>`<font style="color:rgb(0,0,0);">-r </font>`<font style="color:rgb(0,0,0);">选项指定 zip 命令应该对每个目录重复执行，例如应该包含所有子目录和文件。这两个选项可以用</font>`<font style="color:rgb(0,0,0);"> -qr </font>`<font style="color:rgb(0,0,0);">结合到一起。选项后面跟的是要备份到 zip 文档的文件和目录列表。我们用 join 方法将资源列表转换成一个字符串，</font>`<font style="color:rgb(0,0,0);">join</font>`<font style="color:rgb(0,0,0);"> 方法在上面已经讲过如何使用。 </font>

<font style="color:rgb(0,0,0);">然后，我们最后用</font>`<font style="color:rgb(0,0,0);"> os.system</font>`<font style="color:rgb(0,0,0);"> 函数运行命令，该函数就好像我们在系统中直接运行命令一样，例如在 shell 中，如果命令运行成功则返回 0，否则返回错误代码。 根据命令的结果，我们打印适当的消息来说明备份失败还是成功。 </font>

<font style="color:rgb(0,0,0);">好了，我们已尽建立了一个脚本来备份我们的重要文件。 </font>

**<font style="color:rgb(0,0,0);">给 </font>****<font style="color:rgb(0,0,0);">windows </font>****<font style="color:rgb(0,0,0);">用户的注释： </font>**

<font style="color:rgb(0,0,0);">不用双反斜杠转义字符串，你可以用自然字符串。例如，用</font>`<font style="color:rgb(0,0,0);">'C:\\Documents'</font>`<font style="color:rgb(0,0,0);">或</font>`<font style="color:rgb(0,0,0);">'D:\Documents'</font>`<font style="color:rgb(0,0,0);">。 </font>

<font style="color:rgb(0,0,0);">但不要用</font>`<font style="color:rgb(0,0,0);">'D:\Documents'</font>`<font style="color:rgb(0,0,0);">，因为你以未知转义字符</font>`<font style="color:rgb(0,0,0);">\D</font>`<font style="color:rgb(0,0,0);"> 结束。 </font>

<font style="color:rgb(0,0,0);">现在我们已经有了一个可以工作的备份脚本，我们可以在任何我们想要建立文件备份的时候使用它。建议</font>`<font style="color:rgb(0,0,0);"> Linux/Unix </font>`<font style="color:rgb(0,0,0);">用户使用前面介绍的可执行的方法，这样就可以在任何地方任何时候运行备份脚本了。这被称为软件的实施环节或开发环节。 </font>

<font style="color:rgb(0,0,0);">上面的程序可以正确工作，但是（通常）第一个程序并不是与你所期望的完全一样。例如，可能有些问题你没有设计恰当，又或者你在输入代码的时候发生了一点错误，等等。正常情况下，你应该回到设计环节或者调试程序。 </font>

# <font style="color:rgb(0,0,0);">第二版 </font>
<font style="color:rgb(0,0,0);">第一个版本的脚本可以工作。然而，我们可以对它做些优化以便让它在我们的日常工作中变得更好。这称为软件的维护环节。 </font>

<font style="color:rgb(0,0,0);">我认为优化之一是采用更好的文件名机制 —— 使用时间作为文件名，而当前的日期作为目录名，存放在主备份目录中。这样做的一个优势是你的备份会以等级结构存储，因此它就更加容易管理了。另外一个优势是文件名的长度也可以变短。还有一个优势是采用各自独立的文件夹可以帮助你方便地检验你是否在每一天创建了备份，因为只有在你创建了备份，才会出现那天的目录。 </font>

```python
#!/usr/bin/python 
# Filename: backup_ver2.py 
import os
import time

# 1. The files and directories to be backed up are
# specified in a list.
# Example on Windows:
# source = ['"C:\\My Documents"', 'C:\\Code']
# Example on Mac OS X and Linux:
source = ['/Users/swa/notes']
# Notice we had to use double quotes inside the string
# for names with spaces in it.

# 2. The backup must be stored in a
# main backup directory
# Example on Windows:
# target_dir = 'E:\\Backup'
# Example on Mac OS X and Linux:
target_dir = '/Users/swa/backup'
# Remember to change this to which folder you will be using

# Create target directory if it is not present
if not os.path.exists(target_dir):
    os.mkdir(target_dir)  # make directory

# 3. The files are backed up into a zip file.
# 4. The current day is the name of the subdirectory
# in the main directory.
today = target_dir + os.sep + time.strftime('%Y%m%d')
# The current time is the name of the zip archive.
now = time.strftime('%H%M%S')

# The name of the zip file
target = today + os.sep + now + '.zip'

# Create the subdirectory if it isn't already there
if not os.path.exists(today):
    os.mkdir(today)
    print('Successfully created directory', today)

# 5. We use the zip command to put the files in a zip archive
zip_command = 'zip -r {0} {1}'.format(target,
                                      ' '.join(source))

# Run the backup
print('Zip command is:')
print(zip_command)
print('Running:')
if os.system(zip_command) == 0:
    print('Successful backup to', target)
else:
    print('Backup FAILED')
```

<font style="color:rgb(0,0,0);">输出： </font>

```python
$ python backup_ver2.py
Successfully created directory /Users/swa/backup/20140329
Zip command is:
zip -r /Users/swa/backup/20140329/073201.zip /Users/swa/notes
Running:
  adding: Users/swa/notes/ (stored 0%)
  adding: Users/swa/notes/blah1.txt (stored 0%)
  adding: Users/swa/notes/blah2.txt (stored 0%)
  adding: Users/swa/notes/blah3.txt (stored 0%)
Successful backup to /Users/swa/backup/20140329/073201.zip
```

<font style="color:rgb(0,0,0);">如何工作： </font>

<font style="color:rgb(0,0,0);">两个程序的大部分是相同的。改变的部分主要是使用 os.exists 函数检验在主备份目录中是否有以当前日期作为名称的目录。如果没有，我们使用 os.mkdir 函数创建。 </font>

<font style="color:rgb(0,0,0);">（译者注：注意 os.sep 变量的用法 —— 这会根据你的操作系统给出目录分隔符，即在Linux、Unix 下它是’/’，在 Windows 下它是’\\’，而在 Mac OS 下它是’:’。使用os.sep而非直接使用字符，会使我们的程序具有移植性，可以在上述这些系统下工作。） </font>

# <font style="color:rgb(0,0,0);">第三版 </font>
<font style="color:rgb(0,0,0);">第二个版本在我做较多备份的时候还工作得不错，但是如果有极多备份的时候，我发现要区分每个备份是干什么的，会变得十分困难！例如，我可能对程序或者演讲稿做了一些重要的改变，于是我想要把这些改变与 zip 归档的名称联系起来。这可以通过在 zip 归档名上附带一个用户提供的注释来方便地实现。 </font>

**<font style="color:rgb(0,0,0);">注释： </font>**

<font style="color:rgb(0,0,0);">下面的程序不能运行，所以不要慌，请跟着一起因为这儿还有一课。 </font>

```python
#!/usr/bin/python 
# Filename: backup_ver3.py 
import os
import time

# 1. The files and directories to be backed up are
# specified in a list.
# Example on Windows:
# source = ['"C:\\My Documents"', 'C:\\Code']
# Example on Mac OS X and Linux:
source = ['/Users/swa/notes']
# Notice we had to use double quotes inside the string
# for names with spaces in it.

# 2. The backup must be stored in a
# main backup directory
# Example on Windows:
# target_dir = 'E:\\Backup'
# Example on Mac OS X and Linux:
target_dir = '/Users/swa/backup'
# Remember to change this to which folder you will be using

# Create target directory if it is not present
if not os.path.exists(target_dir):
    os.mkdir(target_dir)  # make directory

# 3. The files are backed up into a zip file.
# 4. The current day is the name of the subdirectory
# in the main directory.
today = target_dir + os.sep + time.strftime('%Y%m%d')
# The current time is the name of the zip archive.
now = time.strftime('%H%M%S')

# Take a comment from the user to
# create the name of the zip file
comment = input('Enter a comment --> ')
# Check if a comment was entered
if len(comment) == 0:
    target = today + os.sep + now + '.zip'
else:
    target = today + os.sep + now + '_' + 
        comment.replace(' ', '_') + '.zip'

# Create the subdirectory if it isn't already there
if not os.path.exists(today):
    os.mkdir(today)
    print('Successfully created directory', today)

# 5. We use the zip command to put the files in a zip archive
zip_command = "zip -r {0} {1}".format(target,
                                      ' '.join(source))

# Run the backup
print('Zip command is:')
print(zip_command)
print('Running:')
if os.system(zip_command) == 0:
    print('Successful backup to', target)
else:
    print('Backup FAILED')
```

<font style="color:rgb(0,0,0);">输出： </font>

```python
$ python backup_ver3.py
  File "backup_ver3.py", line 39
    target = today + os.sep + now + '_' +
                                        ^
SyntaxError: invalid syntax
```

<font style="color:rgb(0,0,0);">如何（不）工作： </font>

<font style="color:rgb(0,0,0);">这个程序不工作！Python 说有一个语法错误，这意味着脚本不满足 Python 可以识别的结构。当我们观察 Python 给出的错误的时候，它也告诉了我们它检测出错误的位置。所以我们从那行开始调试我们的程序。 </font>

<font style="color:rgb(0,0,0);">通过仔细的观察，我们发现一个逻辑行被分成了两个物理行，但是我们并没有指明这两个物理行属于同一逻辑行。基本上，Python 发现加法操作符（＋）在那一逻辑行没有任何操作数，因此它不知道该如何继续。记住我们可以使用物理行尾的反斜杠来表示逻辑行在下一物理行继续。所以，我们修正了程序。这被称为 bug 修订。 </font>

# <font style="color:rgb(0,0,0);">第四版 </font>
```python
#!/usr/bin/python 
# Filename: backup_ver4.py 
import os
import time

# 1. The files and directories to be backed up are
# specified in a list.
# Example on Windows:
# source = ['"C:\\My Documents"', 'C:\\Code']
# Example on Mac OS X and Linux:
source = ['/Users/swa/notes']
# Notice we had to use double quotes inside the string
# for names with spaces in it.

# 2. The backup must be stored in a
# main backup directory
# Example on Windows:
# target_dir = 'E:\\Backup'
# Example on Mac OS X and Linux:
target_dir = '/Users/swa/backup'
# Remember to change this to which folder you will be using

# Create target directory if it is not present
if not os.path.exists(target_dir):
    os.mkdir(target_dir)  # make directory

# 3. The files are backed up into a zip file.
# 4. The current day is the name of the subdirectory
# in the main directory.
today = target_dir + os.sep + time.strftime('%Y%m%d')
# The current time is the name of the zip archive.
now = time.strftime('%H%M%S')

# Take a comment from the user to
# create the name of the zip file
comment = input('Enter a comment --> ')
# Check if a comment was entered
if len(comment) == 0:
    target = today + os.sep + now + '.zip'
else:
    target = today + os.sep + now + '_' + \
        comment.replace(' ', '_') + '.zip'

# Create the subdirectory if it isn't already there
if not os.path.exists(today):
    os.mkdir(today)
    print('Successfully created directory', today)

# 5. We use the zip command to put the files in a zip archive
zip_command = 'zip -r {0} {1}'.format(target,
                                      ' '.join(source))

# Run the backup
print('Zip command is:')
print(zip_command)
print('Running:')
if os.system(zip_command) == 0:
    print('Successful backup to', target)
else:
    print('Backup FAILED')
```

<font style="color:rgb(0,0,0);">输出： </font>

```python
$ python backup_ver4.py
Enter a comment --> added new examples
Zip command is:
zip -r /Users/swa/backup/20140329/074122_added_new_examples.zip /Users/swa/notes
Running:
  adding: Users/swa/notes/ (stored 0%)
  adding: Users/swa/notes/blah1.txt (stored 0%)
  adding: Users/swa/notes/blah2.txt (stored 0%)
  adding: Users/swa/notes/blah3.txt (stored 0%)
Successful backup to /Users/swa/backup/20140329/074122_added_new_examples.zip
```

<font style="color:rgb(0,0,0);">如何工作： </font>

<font style="color:rgb(0,0,0);">这个程序现在工作了！让我们看一下版本三中作出的实质性改进。我们使用input 函数得到用户的注释，然后通过 len 函数找出输入的长度以检验用户是否确实输入了什么东西。如果用户只是按了回车（比如这只是一个惯例备份，没有做什么特别的修改），那么我们就如之前那样继续操作。 </font>

<font style="color:rgb(0,0,0);">然而，如果提供了注释，那么它会被附加到 zip 归档名，就在.zip 扩展名之前。注意我们把注释中的空格替换成下划线 (_)—— 这是因为处理这样的文件名要容易得多。 </font>

# <font style="color:rgb(0,0,0);">更多的提炼 </font>
<font style="color:rgb(0,0,0);">对于大多数用户来说，第四个版本是一个满意的工作脚本了，但是它仍然有进一步改进的空间。比如，你可以在程序中包含交互程度 —— 你可以用 -v 选项来使你的程序更具交互性。 </font>

<font style="color:rgb(0,0,0);">另一个可能的改进是使文件和目录能够通过命令行直接传递给脚本。我们可以通过 sys.argv 列表来获取它们，然后我们可以使用 list 类提供的 extend 方法把它们加到source 列表中去。 </font>

<font style="color:rgb(0,0,0);">最重要的提炼就是不用 os.system 方式来创建压缩文档，而是用 zipfile 或 tarfile内置模块来创建压缩文档。它们是标准库的一部分，没有与你计算机中外部 zip 程序的依赖性，并且已经能够使用。 </font>

<font style="color:rgb(0,0,0);">但是，在上面的例子中，我已经使用了 os.system 的方式创建备份，这纯粹是为教学的方便，以使得例子足够简单，能被每个人理解，但这已经足够用了。</font>

<font style="color:rgb(0,0,0);">你能尝试用</font>[zipfile ](https://docs.python.org/3/library/zipfile.html)<font style="color:rgb(0,0,0);">模块来替代 os.system 调用写出第四版吗？ </font>

# <font style="color:rgb(0,0,0);">软件开发过程 </font>
<font style="color:rgb(0,0,0);">现在，我们已经走过了编写一个软件的各个环节。这些环节可以概括如下： </font>

1. <font style="color:rgb(0,0,0);">什么（分析） </font>
2. <font style="color:rgb(0,0,0);">如何（设计） </font>
3. <font style="color:rgb(0,0,0);">编写（实施） </font>
4. <font style="color:rgb(0,0,0);">测试（测试与调试） </font>
5. <font style="color:rgb(0,0,0);">使用（实施或开发） </font>
6. <font style="color:rgb(0,0,0);">维护（优化） </font>

<font style="color:rgb(0,0,0);">我们创建这个备份脚本的过程是编写程序的推荐方法 —— 进行分析与设计。开始时实施一个简单的版本。对它进行测试与调试。使用它以确信它如预期那样地工作。再增加任何你想要的特性，根据需要一次次重复这个编写－测试－使用的周期。 </font>

<font style="color:rgb(0,0,0);">记住“软件是长出来的，而不是建造的”。 </font>

# <font style="color:rgb(0,0,0);">概括 </font>
<font style="color:rgb(0,0,0);">我们已经学习如何创建我们自己的 Python 程序/脚本，以及在编写这个程序中所设计到的不同的状态。你可以发现它们在创建你自己的程序的时候会十分有用，让你对 Python 以及解决问题都变得更加得心应手。 </font>

<font style="color:rgb(0,0,0);">接下来，我们将讨论面向对象的编程。 </font>





