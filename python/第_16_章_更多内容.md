# <font style="color:rgb(0,0,0);">16.1 简介 </font>
<font style="color:rgb(0,0,0);">到目前为止，我们已经学习了绝大多数常用的 Python 知识。在这一章中，我们将要学习另外一些方面的 Python 知识，从而使我们对 Python 的了解更加完整。 </font>

# <font style="color:rgb(0,0,0);">16.2 传送元组 </font>
<font style="color:rgb(0,0,0);">你曾想过在一个函数中返回两个不同的值吗？你可以。要做的就是使用元组。 </font>

```bash
>>> def get_error_details():
...     return (2, 'details')
...
>>> errnum, errstr = get_error_details()
>>> errnum
2
>>> errstr
'details'
```

<font style="color:rgb(0,0,0);">注意 a, b = <some expression> 可以解释为有两个值的元组表达式的结果。 如果想将结果解释为 (a, <everything else>)，你需要用星来表示，就如在函数参数中的那样。 </font>

```bash
>>> a = 5; b = 8
>>> a, b
(5, 8)
>>> a, b = b, a
>>> a, b
(8, 5)
```

<font style="color:rgb(0,0,0);">在 </font><font style="color:rgb(0,0,0);">Python </font><font style="color:rgb(0,0,0);">中这也意味着交换两个变量的最快的方式： </font>

```bash
>>> a = 5; b = 8 
>>> a, b = b, a 
>>> a, b 
(8, 5) 
```

# <font style="color:rgb(0,0,0);">16.3 特殊方法 </font>
<font style="color:rgb(0,0,0);">有一些如 __init__ 和 __del__ 这样的确定方法，对类来说有重要意义。 特殊的方法用来模仿内置类型的确定动作。例如，如果你想对类使用 x[key] 角标操作（就像你在列表和元组中那样），那么你只需要实现 __getitem__() 方法就可以了。想一下，Python 就是对 list 类这样做的！ </font>

<font style="color:rgb(0,0,0);">下面这个表中列出了一些有用的特殊方法。如果你想要知道所有的特殊方法，你可以在 </font>[参考手册](https://docs.python.org/3/reference/datamodel.html#special-method-names)<font style="color:rgb(0,0,0);">中找到一个庞大的列表。 </font>

+ `<font style="background-color:rgb(247, 247, 247);">__init__(self, ...)</font>`
    - <font style="color:rgb(51, 51, 51);">This method is called just before the newly created object is returned for usage.</font>
+ `<font style="background-color:rgb(247, 247, 247);">__del__(self)</font>`
    - <font style="color:rgb(51, 51, 51);">Called just before the object is destroyed (which has unpredictable timing, so avoid using this)</font>
+ `<font style="background-color:rgb(247, 247, 247);">__str__(self)</font>`
    - <font style="color:rgb(51, 51, 51);">Called when we use the</font><font style="color:rgb(51, 51, 51);"> </font>`<font style="background-color:rgb(247, 247, 247);">print</font>`<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">function or when</font><font style="color:rgb(51, 51, 51);"> </font>`<font style="background-color:rgb(247, 247, 247);">str()</font>`<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">is used.</font>
+ `<font style="background-color:rgb(247, 247, 247);">__lt__(self, other)</font>`
    - <font style="color:rgb(51, 51, 51);">Called when the</font><font style="color:rgb(51, 51, 51);"> </font>_<font style="color:rgb(51, 51, 51);">less than</font>_<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">operator (<) is used. Similarly, there are special methods for all the operators (+, >, etc.)</font>
+ `<font style="background-color:rgb(247, 247, 247);">__getitem__(self, key)</font>`
    - <font style="color:rgb(51, 51, 51);">Called when</font><font style="color:rgb(51, 51, 51);"> </font>`<font style="background-color:rgb(247, 247, 247);">x[key]</font>`<font style="color:rgb(51, 51, 51);"> </font><font style="color:rgb(51, 51, 51);">indexing operation is used.</font>
+ `<font style="background-color:rgb(247, 247, 247);">__len__(self)</font>`
    - <font style="color:rgb(51, 51, 51);">Called when the built-in </font>`<font style="background-color:rgb(247, 247, 247);">len()</font>`<font style="color:rgb(51, 51, 51);"> function is used for the sequence object.</font>

# <font style="color:rgb(0,0,0);">16.4 单语句块 </font>
<font style="color:rgb(0,0,0);">现在，你已经很深刻地理解了每一个语句块是通过它的缩进层次与其它块区分开来的。然而这在大多数情况下是正确的，但是并非 100% 的准确。如果你的语句块只包含一句语句，那么你可以在条件语句或循环语句的同一行指明它。下面这个例子清晰地说明了这一点： </font>

```bash
>>> flag = True
>>> if flag: print('Yes')
...
Yes
```

<font style="color:rgb(0,0,0);">就如你所看见的，单个语句被直接使用而不是作为一个独立的块使用。虽然这样做可以使你的程序变得小一些，但是除了检验错误之外我强烈建议你不要使用这种缩略方法。不使用它的一个主要的理由是一旦你使用了恰当的缩进，你就可以很方便地添加一个额外的语句。 </font>

# <font style="color:rgb(0,0,0);">16.5 Lambda 形式 </font>
<font style="color:rgb(0,0,0);">lambda </font><font style="color:rgb(0,0,0);">语句被用来创建新的函数对象，并且在运行时返回它们。 </font>

```bash
# !/usr/bin/python 
# Filename: lambda.py 
points = [{'x': 2, 'y': 3},
          {'x': 4, 'y': 1}]
points.sort(key=lambda i: i['y'])
print(points)
```

<font style="color:rgb(0,0,0);">输出： </font>

```bash
$ python more_lambda.py
[{'y': 1, 'x': 4}, {'y': 3, 'x': 2}]
```

<font style="color:rgb(0,0,0);">如何工作： </font>

<font style="color:rgb(0,0,0);">这里，我们使用了 make_repeater 函数在运行时创建新的函数对象，并且返回它。 lambda 语句用来创建函数对象。本质上，lambda 需要一个参数，后面仅跟单个表达式作为函数体，而表达式的值被这个新建的函数返回。注意，即便是 print 语句也不能用在 lambda 形式中，只能使用表达式。 </font>

<font style="color:rgb(0,0,0);">要做的事： </font>

<font style="color:rgb(0,0,0);">你能通过用 lambda 创建的比较函数来完成 list.sort() 吗？ </font>

```bash
points = [ { 'x' : 2, 'y' : 3 }, { 'x' : 4, 'y' : 1 } ] 
# points.sort(lambda a, b : cmp(a['x'], b['x'])) 
```

# <font style="color:rgb(0,0,0);">16.6 列表综合 </font>
<font style="color:rgb(0,0,0);">通过列表综合，可以从一个已有的列表导出一个新的列表。例如，你有一个数的列表，而你想要得到一个对应的列表，使其中所有大于 2 的数都是原来的 2 倍。对于这种应用，列表综合是最理想的方法。 </font>

```bash
# !/usr/bin/python 
# Filename: list_comprehension.py 
listone = [2, 3, 4]
listtwo = [2*i for i in listone if i > 2]
print(listtwo)
```

<font style="color:rgb(0,0,0);">输出： </font>

```bash
$ python more_list_comprehension.py
[6, 8]
```

<font style="color:rgb(0,0,0);">如何工作： </font>

<font style="color:rgb(0,0,0);">这里我们为满足条件（if i > 2）的数指定了一个操作（2*i），从而导出一个新的列表。注意原来的列表并没有发生变化。 </font>

<font style="color:rgb(0,0,0);">使用列表综合的好处就是他会生成与循环生成每一个元素然后在一个新的列表中存储它一样的工作。 </font>

# <font style="color:rgb(0,0,0);">16.7 在函数中接收元组和列表 </font>
<font style="color:rgb(0,0,0);">当要使函数接收元组或字典形式的参数的时候，有一种特殊的方法，它分别使用 * 和 ** 前缀。这种方法在函数需要获取可变数量的参数的时候特别有用。 </font>

```bash
>>> def powersum(power, *args):
...     '''Return the sum of each argument raised to the specified power.'''
...     total = 0
...     for i in args:
...         total += pow(i, power)
...     return total
...
>>> powersum(2, 3, 4)
25
>>> powersum(2, 10)
100
```

<font style="color:rgb(0,0,0);">因为在 args 变量前面用了 * 前缀，所有传递给函数的多余的参数都被存储在元组args 中。如果用 ** 前缀，额外的参数都会被以键/值的方式存储在字典中。 </font>

# <font style="color:rgb(0,0,0);">16.8 exec 和 eval 语句 </font>
<font style="color:rgb(0,0,0);">exec 语句用来执行储存在字符串或文件中的 Python 语句。例如，我们可以在运行时生成一个包含 Python 代码的字符串，然后使用 exec 语句执行这些语句： </font>

```bash
>>> exec('print("Hello World")') 
Hello World 
```

<font style="color:rgb(0,0,0);">类似地，</font><font style="color:rgb(0,0,0);">eval </font><font style="color:rgb(0,0,0);">函数用来执行存储在字符串中的 </font><font style="color:rgb(0,0,0);">Python </font><font style="color:rgb(0,0,0);">表达式。简单的例子如 </font>

<font style="color:rgb(0,0,0);">下： </font>

```bash
>>> eval('2*3') 
6 
```

# <font style="color:rgb(0,0,0);">16.9 assert 语句 </font>
<font style="color:rgb(0,0,0);">assert 语句用来声明某个条件是真的。例如，如果你非常确信某个你使用的列表中至少有一个元素，而你想要检验这一点，并且在它非真的时候引发一个错误，那么assert 语句是应用在这种情形下的理想语句。当 assert 语句失败的时候，会引发一个AssertionError。 </font>

```bash
>>> mylist = ['item']
>>> assert len(mylist) >= 1
>>> mylist.pop()
'item'
>>> assert len(mylist) >= 1
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AssertionError
```

<font style="color:rgb(0,0,0);">当然应该明智地使用 </font><font style="color:rgb(0,0,0);">assert </font><font style="color:rgb(0,0,0);">语句。多数情况下，最好用来捕获异常，而不是处理 </font>

<font style="color:rgb(0,0,0);">问题或者给用户显示出错的消息然后退出。 </font>

# <font style="color:rgb(0,0,0);">16.10 repr 函数 </font>
<font style="color:rgb(0,0,0);">repr 函数用来取得对象的规范字符串表示。注意，在大多数时候有 </font>`<font style="color:rgb(0,0,0);">eval(repr(object))== object</font>`<font style="color:rgb(0,0,0);">。 </font>

```bash
>>> i = [] 
>>> i.append('item') 
>>> i 
['item'] 
>>> repr(i) 
"['item']" 
>>> eval(repr(i)) 
['item'] 
>>> eval(repr(i)) == i 
True 
```

<font style="color:rgb(0,0,0);">基本上，repr 函数用来获取对象的可打印的表示形式。你可以通过定义类的__repr__ 方法来控制你的对象在被 repr 函数调用的时候返回的内容。 </font>

# <font style="color:rgb(0,0,0);">16.11 概括 </font>
<font style="color:rgb(0,0,0);">在这一章中，我们又学习了一些 Python 的特色，然而你可以肯定我们并没有学习完 Python 的所有特色。不过，到目前为止，我们确实已经学习了绝大多数你在实际中会使用的内容。这些已经足以让你去创建任何程序了。 </font>

<font style="color:rgb(0,0,0);">接下来，我们会讨论一下如何进一步深入探索 Python。 </font>





